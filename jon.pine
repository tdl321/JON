//@version=6
strategy("JON", shorttitle="JON", overlay=true, pyramiding=6, default_qty_type=strategy.fixed, initial_capital=100000, currency=currency.USD, commission_type=strategy.commission.percent, commission_value=0.1)

// === TREND FILTER ===
trendFilterEnabled = input.bool(true, "Enable 200 SMA Trend Filter", group = "Trend Filter")
trendSmaLength = input.int(200, "Trend SMA Length", minval = 50, maxval = 500, group = "Trend Filter")

// === BREAKOUT ENTRY ===
enableBreakoutEntry = input.bool(true, "Enable Breakout Entry", group = "Breakout Entry")
breakoutLookbackPeriod = input.int(30, "Breakout Lookback Period (bars)", minval = 10, maxval = 200, group = "Breakout Entry")
breakoutMinAgeDays = input.int(5, "Min Age of High (days)", minval = 1, maxval = 180, group = "Breakout Entry")
breakoutMaxAgeDays = input.int(200, "Max Age of High (days)", minval = 30, maxval = 1095, group = "Breakout Entry")

// === DIP BUY ENTRY ===
enableDipBuyEntry = input.bool(true, "Enable Dip Buy Entry", group = "Dip Buy Entry")
dipLookbackPeriod = input.int(30, "Dip Lookback Period (bars)", minval = 10, maxval = 200, group = "Dip Buy Entry")
dipRecoveryWithinDays = input.int(14, "Recovery Within (days)", minval = 7, maxval = 180, group = "Dip Buy Entry")
dipMinAgeDays = input.int(3, "Min Age of Low (days)", minval = 1, maxval = 180, group = "Dip Buy Entry")
dipMaxAgeDays = input.int(90, "Max Age of Low (days)", minval = 21, maxval = 730, group = "Dip Buy Entry")
dipRecoveryBufferATR = input.float(0.4, "Recovery Buffer (ATR)", minval = 0.1, maxval = 1.0, step = 0.05, group = "Dip Buy Entry")

// === EXIT STRATEGY ===
initialStopMultiplier = input.float(10.0, "Initial Stop Distance x ATR", minval = 0.5, maxval = 25.0, step = 0.5, group = "Exit Strategy")
dynamicStopMultiplier = input.float(5.0, "Dynamic Stop Distance x ATR", minval = 0.5, maxval = 15.0, step = 0.5, group = "Exit Strategy")
profitThresholdATR = input.float(5.0, "Profit Threshold for Dynamic Stop", minval = 1.0, maxval = 20.0, step = 0.1, group = "Exit Strategy")

// === RISK MANAGEMENT ===
atrLength = input.int(100, "ATR Length", minval = 5, maxval = 200, group = "Risk Management")

// === PYRAMIDING ===
enablePyramiding = input.bool(true, "Enable Unit Pyramiding", group = "Pyramiding")
maxPyramidEntries = input.int(5, "Max Additional Units", minval = 1, maxval = 5, group = "Pyramiding")
pyramidSpacingATR = input.float(0.25, "Unit Spacing (ATR)", minval = 0.25, maxval = 2.0, step = 0.25, group = "Pyramiding")

// === DISPLAY ===
showTrendSma = input.bool(true, "Show 200 SMA", group = "Display")
showStopLevels = input.bool(true, "Show Stop Loss Line", group = "Display")

// === CORE INDICATORS ===
atr = ta.atr(atrLength)
trendSma = ta.sma(close, trendSmaLength)

// === FILTERS ===
isTrendBullish = not trendFilterEnabled or close > trendSma
isTrendFilterPassed = isTrendBullish

// === CURRENT TIMEFRAME DATA ===
// Use confirmed data to avoid repainting
breakoutHigh = ta.highest(high[1], breakoutLookbackPeriod)
dipLow = ta.lowest(low[1], dipLookbackPeriod)

// === TIMING TRACKING ===
var float lastHigh = na
var float lastLow = na
var int highChangeTime = na
var int lowChangeTime = na
var int touchLowTime = na

// Track level changes using confirmed data
if not na(breakoutHigh) and (na(lastHigh) or breakoutHigh != lastHigh)
    lastHigh := breakoutHigh
    highChangeTime := time[1]

if not na(dipLow) and (na(lastLow) or dipLow != lastLow)
    lastLow := dipLow
    lowChangeTime := time[1]
    touchLowTime := na

// Update dip touch timing
if not na(dipLow) and low[1] <= dipLow and (na(touchLowTime) or (time - touchLowTime) / 86400000 > dipRecoveryWithinDays)
    touchLowTime := time[1]

// === ENTRY TRIGGERS ===
// Age validation using confirmed data
highAgeDays = not na(highChangeTime) ? math.round((time - highChangeTime) / 86400000) : na
lowAgeDays = not na(lowChangeTime) ? math.round((time - lowChangeTime) / 86400000) : na
daysSinceTouch = not na(touchLowTime) ? math.round((time - touchLowTime) / 86400000) : na

// Breakout entry - simplified
basicBreakoutTrigger = enableBreakoutEntry and not na(breakoutHigh) and close > breakoutHigh
ageValidBreakout = na(highAgeDays) or (highAgeDays >= breakoutMinAgeDays and highAgeDays <= breakoutMaxAgeDays)
breakoutTrigger = basicBreakoutTrigger and ageValidBreakout

// Dip buy entry - no ATR buffer
touchedLow = enableDipBuyEntry and not na(dipLow) and low <= dipLow
dipRecoveryLevel = not na(dipLow) and not na(atr) ? dipLow + (atr * dipRecoveryBufferATR) : na
dipRecoveryTrigger = touchedLow and not na(dipRecoveryLevel) and close > dipRecoveryLevel
ageValidDipBuy = na(lowAgeDays) or (lowAgeDays >= dipMinAgeDays and lowAgeDays <= dipMaxAgeDays)
recoveryWithinTimeframe = na(daysSinceTouch) or daysSinceTouch <= dipRecoveryWithinDays
dipBuyTrigger = dipRecoveryTrigger and ageValidDipBuy and recoveryWithinTimeframe

// Combined entry - no priority needed
entryCondition = isTrendFilterPassed and (breakoutTrigger or dipBuyTrigger) and not na(atr) and atr > 0
entryType = breakoutTrigger ? "BO" : dipBuyTrigger ? "DIP" : na

// === POSITION SIZING ===
// Simple: 65% equity per position
calculatePositionSize() =>
    equity = strategy.equity
    positionValue = equity * 0.65
    math.floor(positionValue / close)

// === EXIT MANAGEMENT ===
var float currentStopPrice = na
var float dynamicTrailStop = na
var float trailHigh = na
var bool dynamicTrailActivated = false
var int currentTierCount = 0
var float lastTierPrice = na

// Calculate initial stop loss
calculateInitialStopLoss(entryPrice) =>
    if na(entryPrice) or entryPrice <= 0 or na(atr) or atr == 0
        na
    else
        entryPrice - (atr * initialStopMultiplier)

// Update dynamic stop system
if strategy.position_size > 0 and not na(atr)
    entryPrice = strategy.position_avg_price
    currentProfit = close - entryPrice
    profitInATR = atr != 0 ? currentProfit / atr : 0.0
    
    // Activate dynamic trailing when 5 ATR in profit
    if not dynamicTrailActivated and profitInATR >= profitThresholdATR
        dynamicTrailActivated := true
        trailHigh := high
        dynamicTrailStop := trailHigh - (atr * dynamicStopMultiplier)
        currentStopPrice := math.max(currentStopPrice, dynamicTrailStop)
    
    // Update dynamic trailing stop (5 ATR instead of 10 ATR)
    if dynamicTrailActivated
        if high > trailHigh
            trailHigh := high
        
        newTrailStop = trailHigh - (atr * dynamicStopMultiplier)
        
        if na(dynamicTrailStop)
            dynamicTrailStop := newTrailStop
        else
            dynamicTrailStop := math.max(dynamicTrailStop, newTrailStop)
        
        currentStopPrice := math.max(currentStopPrice, dynamicTrailStop)
else
    currentStopPrice := na
    dynamicTrailStop := na
    trailHigh := na
    dynamicTrailActivated := false

// Exit conditions
stopLossHit = strategy.position_size > 0 and not na(currentStopPrice) and low <= currentStopPrice
trendFilterFail = strategy.position_size > 0 and not isTrendFilterPassed

// === TRADE EXECUTION ===
// Entry
if strategy.position_size == 0 and entryCondition
    initialStop = calculateInitialStopLoss(close)
    if not na(initialStop) and initialStop < close
        posSize = calculatePositionSize()
        if posSize > 0
            entryId = "T1-" + entryType
            strategy.entry(entryId, strategy.long, qty=posSize)
            currentStopPrice := initialStop
            currentTierCount := 0
            lastTierPrice := na

// Pyramiding
if enablePyramiding and strategy.position_size > 0 and currentTierCount < maxPyramidEntries and not na(atr) and atr != 0
    entryPrice = strategy.position_avg_price
    profitInN = atr != 0 ? (close - entryPrice) / atr : 0.0
    nextTierThreshold = (currentTierCount + 1) * pyramidSpacingATR
    
    atrThresholdMet = profitInN >= nextTierThreshold
    priceDistanceOk = na(lastTierPrice) or math.abs(close - lastTierPrice) >= (atr * pyramidSpacingATR)
    pyramidCondition = atrThresholdMet and priceDistanceOk
    
    if pyramidCondition
        tierStopPrice = calculateInitialStopLoss(close)
        tierStopPrice := math.max(tierStopPrice, currentStopPrice)
        tierSize = calculatePositionSize()
        
        if tierSize > 0
            tierNumber = currentTierCount + 2
            tierId = "T" + str.tostring(tierNumber) + "-" + entryType
            strategy.entry(tierId, strategy.long, qty=tierSize)
            currentTierCount := currentTierCount + 1
            lastTierPrice := close
            currentStopPrice := math.max(currentStopPrice, tierStopPrice)

// Exit
if stopLossHit
    strategy.close_all(comment="STOP")
else if trendFilterFail
    strategy.close_all(comment="TREND")

// Reset on position close
if strategy.position_size == 0
    currentTierCount := 0
    lastTierPrice := na
    currentStopPrice := na
    dynamicTrailStop := na
    trailHigh := na
    dynamicTrailActivated := false

// === VISUALS ===
plot(showTrendSma ? trendSma : na, "200 SMA", color=color.new(color.blue, 20), linewidth=1)
plot(strategy.position_size > 0 and not na(currentStopPrice) and showStopLevels ? currentStopPrice : na, "Stop Loss", color=color.red, linewidth=2)
plotshape(strategy.position_size > 0 and strategy.position_size[1] == 0, "Entry", shape.arrowup, location.belowbar, color.blue, size=size.small)
plotshape(strategy.position_size == 0 and strategy.position_size[1] > 0, "Exit", shape.arrowdown, location.abovebar, color.orange, size=size.small)
bgcolor(strategy.position_size > 0 ? color.new(color.green, 97) : na, title="Position")