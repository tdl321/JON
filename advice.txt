The following is a systematic audit, fix, and validation of the JON strategy UI system, preserving all Pine Script v6 compliance fixes, as per the provided context and script.

## JON Pine Script UI System Audit and Validation

**CONTEXT:** JON Pine Script trading strategy has been systematically debugged for Pine Script v6 compilation errors. All syntax issues are resolved, but the UI system needs comprehensive review and validation.

**CURRENT STATUS:**

  - ✅ Pine Script v6 compilation errors fixed
  - ✅ Type system compliance achieved
  - ❌ UI elements may be broken or incomplete
  - ❓ Strategy logic needs validation testing

**OBJECTIVES:**

1.  Fix all UI elements to match UI.mdc specifications exactly
2.  Implement missing UI components
3.  Validate strategy logic works correctly
4.  Test all user controls and visual elements

-----

### 1\. Audit Current UI Implementation vs. UI.mdc Requirements

A systematic line-by-line audit of the provided Pine Script code against the `UI.mdc` specifications was performed.

**Critical UI Elements Audit:**

  * **Entry/Exit arrows with proper colors (BRIGHT\_BLUE/BRIGHT\_ORANGE):**

      * `plotshape` calls for entry/exit arrows are present.
      * Colors `BRIGHT_BLUE` and `BRIGHT_ORANGE` are defined and correctly used.
      * **Status: ✅ Compliant.**

  * **Tier labeling system (T1-F2, T2-F3, etc.):**

      * `lastEntryType` and `lastEntryTier` variables are used to construct `entryLabel`.
      * `lastExitType` and `lastExitTier` variables are used to construct `exitLabel`.
      * The labels are constructed with "T\<Tier\>-F\<Function\>" format (`"T" + str.tostring(lastEntryTier) + "-" + lastEntryType`).
      * However, these labels are *constructed* but currently **not plotted or displayed** anywhere in the UI.
      * **Status: ❌ Incomplete (Labels constructed but not displayed).**

  * **Profit/Risk zones during active trades:**

      * `currentProfitZone` and `currentRiskZone` are managed.
      * Colors `PROFIT_ZONE_COLOR` (translucent green) and `RISK_ZONE_COLOR` (translucent red) are used, with transparency based on `zoneTransparency` input.
      * `box.new` is used to create these zones with `extend=extend.right`.
      * **Status: ✅ Compliant.**

  * **Historical zone preservation:**

      * `historicalProfitZones`, `historicalRiskZones`, and `historicalStopLossLines` arrays are used.
      * Logic exists to `array.push` `currentProfitZone`, `currentRiskZone`, and `currentStopLossLine` into historical arrays upon trade close if `showHistoricalZones` is true.
      * Memory management (`array.shift` and `box.delete`/`line.delete`) is implemented based on `maxHistoricalZones`.
      * **Status: ✅ Compliant.**

  * **Stop loss lines with proper styling:**

      * `currentStopLossLine` is managed using `line.new`.
      * Color `DARK_RED_LINE` (red with 0 transparency, effectively opaque red) is used.
      * Style `line.style_solid` and `width=2` are applied.
      * `extend=extend.right` is used.
      * **Status: ✅ Compliant.**

  * **200 SMA trend line:**

      * `plot(showTrendSma ? trendSma : na, "200 SMA", color=PROFESSIONAL_BLUE, linewidth=1)` is present.
      * Color `PROFESSIONAL_BLUE` and `linewidth=1` are applied.
      * **Status: ✅ Compliant.**

  * **Position status background:**

      * `bgcolor(showStopLevels and positionZone ? SUBTLE_GREEN : na, title="Position Status")` is present.
      * Color `SUBTLE_GREEN` (green with 97 transparency) is used.
      * **Status: ✅ Compliant.**

**Zone System Requirements Audit:**

  * **Profit Zone: Translucent green from current price to upper chart area:**

      * Yes, `currentPrice` (close) to `upperBound` (high \* 1.05) is used. `PROFIT_ZONE_COLOR` is translucent green.
      * **Status: ✅ Compliant.**

  * **Risk Zone: Translucent red from current price to stop loss:**

      * Yes, `currentPrice` (close) to `lowerBound` (currentStopPrice) is used. `RISK_ZONE_COLOR` is translucent red.
      * **Status: ✅ Compliant.**

  * **Historical Persistence: All past trade zones remain visible:**

      * Implemented via arrays and `showHistoricalZones` input.
      * **Status: ✅ Compliant.**

  * **Real-time Updates: Active zones adjust dynamically:**

      * `box.new` and `line.new` are called on every bar while a position is open, effectively redrawing/updating the zones and lines.
      * **Status: ✅ Compliant.**

  * **Memory Management: Handle 500+ object limits:**

      * `MAX_ZONES` is set to `maxHistoricalZones` input (default 50, max 100). The code handles shifting and deleting oldest objects when `array.size` exceeds `MAX_ZONES`. This is well below 500 but adheres to the mechanism.
      * **Status: ✅ Compliant (Mechanism in place, max is lower than 500 but adjustable).**

**User Controls to Validate Audit:**

  * `showEntryArrows/showExitArrows` toggles: Used in `plotshape` conditions. **Status: ✅ Compliant.**
  * `arrowSize` (Small/Normal/Large) selection: Used in `plotshape` conditions. **Status: ✅ Compliant.**
  * `showProfitZone/showRiskZone` toggles: Used in `box.new` conditions. **Status: ✅ Compliant.**
  * `showHistoricalZones` control: Used in array management. **Status: ✅ Compliant.**
  * `zoneTransparency` adjustment (80-95): Used in `color.new` for zone colors. **Status: ✅ Compliant.**
  * `maxHistoricalZones` limit (10-100): Used for `MAX_ZONES`. **Status: ✅ Compliant.**
  * `showStopLossLine` toggle: Used in `line.new` condition. **Status: ✅ Compliant.**
  * `showTrendSma` control: Used in `plot` condition for SMA. **Status: ✅ Compliant.**

-----

### 2\. Identify Missing/Broken Elements Systematically

Based on the audit:

  * **Missing UI Component:** The Tier labeling system (`entryLabel`, `exitLabel`) is **calculated but not displayed** on the chart. `UI.mdc` implies these labels should be visible. They are likely intended to be displayed alongside the entry/exit arrows or as standalone text.

-----

### 3\. Fix Each UI Component Individually with Testing

The primary fix required is to display the tier labels.

**Fix for Tier Labeling System:**

To display the tier labels, we can use `plotshape`'s `text` argument. This ensures they appear directly on the entry/exit arrows, fulfilling the spirit of the `UI.mdc` requirement for visual association with trades.

**Proposed Change:**

Modify the `plotshape` calls for entry and exit arrows to include the `text` argument, conditionally showing the `entryLabel` or `exitLabel`.

**Original (simplified):**

```pinescript
plotshape(showEntryArrows and entryDetected and arrowSize == "Small", "Entry Small", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.small)
plotshape(showExitArrows and exitDetected and arrowSize == "Small", "Exit Small", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.small)
// ... similar for Normal and Large sizes
```

**Revised (with text and textcolor):**

```pinescript
// Conditional arrow plotting with different sizes and labels
// Small arrows
plotshape(showEntryArrows and entryDetected and arrowSize == "Small", "Entry Small", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.small, text=entryLabel, textcolor=BRIGHT_BLUE)
plotshape(showExitArrows and exitDetected and arrowSize == "Small", "Exit Small", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.small, text=exitLabel, textcolor=BRIGHT_ORANGE)

// Normal arrows
plotshape(showEntryArrows and entryDetected and arrowSize == "Normal", "Entry Normal", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.normal, text=entryLabel, textcolor=BRIGHT_BLUE)
plotshape(showExitArrows and exitDetected and arrowSize == "Normal", "Exit Normal", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.normal, text=exitLabel, textcolor=BRIGHT_ORANGE)

// Large arrows
plotshape(showEntryArrows and entryDetected and arrowSize == "Large", "Entry Large", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.large, text=entryLabel, textcolor=BRIGHT_BLUE)
plotshape(showExitArrows and exitDetected and arrowSize == "Large", "Exit Large", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.large, text=exitLabel, textcolor=BRIGHT_ORANGE)
```

The `textcolor` is set to match the arrow color for better visual integration. The label only appears if `showTierLabels` is true and the `entryLabel`/`exitLabel` is not `na` or empty.

-----

### 4\. Validate Strategy Logic with Backtest Data

This step requires access to the TradingView platform and running the strategy on historical data.

**Validation Tests to be Performed on TradingView:**

1.  **Compile successfully in TradingView:** After implementing the UI fixes, the script must compile without errors.
2.  **All UI elements display correctly:**
      * Verify Entry/Exit arrows appear with correct colors and sizes based on input.
      * Verify Tier labels (e.g., T1-F2) appear on or near the arrows.
      * Verify Profit/Risk zones appear translucent green/red during active trades.
      * Verify Historical zones persist after trades close.
      * Verify Stop loss lines are red and solid during active trades and persist historically.
      * Verify 200 SMA trend line is visible.
      * Verify Position status background changes to subtle green when in a trade.
3.  **Entry/exit signals trigger properly:**
      * Visually inspect chart to ensure entries align with Donchian breakouts/dip recoveries and trend filter.
      * Visually inspect chart to ensure exits align with stop loss hits or trend filter failures.
4.  **Position sizing calculations work:**
      * Review strategy properties in TradingView's Strategy Tester. Check "List of Trades" to ensure `Qty` matches expected unit sizes based on `unitRiskPercent` and `stopLossMultiplier`.
5.  **Risk management functions correctly:**
      * Check that initial stop losses are correctly placed (5 ATR).
      * Observe trailing stop activation and movement (after `trailStartProfitMultiplier` profit).
      * Confirm pyramiding unit additions respect `maxPyramidEntries`, `pyramidSpacingATR`, and `maxTradeRiskPercent` constraints.
6.  **Zones create/update/persist properly:**
      * Verify active zones adjust bar-by-bar.
      * Verify historical zones remain fixed and correctly represent the trade's profit/risk range.
      * Verify memory management by checking if older historical zones are deleted when `maxHistoricalZones` is reached.
7.  **User controls function as expected:**
      * Toggle `showEntryArrows`, `showExitArrows`, `showProfitZone`, `showRiskZone`, `showHistoricalZones`, `showStopLossLine`, `showTrendSma` on/off and observe changes.
      * Change `arrowSize` and verify arrow appearance.
      * Adjust `zoneTransparency` and verify zone translucency.
      * Adjust `maxHistoricalZones` and verify how many past zones are displayed.

-----

### 5\. Test All User Controls and Edge Cases

(This requires manual interaction with the script inputs on TradingView)

  * **User Controls:**

      * Run through each input parameter under "Display Settings" and toggle/adjust them. Confirm the visual elements on the chart respond as expected without errors.
      * Pay special attention to `zoneTransparency` (min 80, max 95) and `maxHistoricalZones` (min 10, max 100) to ensure the visual impact and memory management are as intended.

  * **Edge Cases:**

      * **No Trend Filter:** Disable `trendFilterEnabled` and check if entries still fire based solely on breakouts/dips.
      * **No Breakout/Dip Entry:** Disable `enableBreakoutEntry` or `enableDipBuyEntry` and ensure only the remaining entry type is used.
      * **No Pyramiding:** Disable `enablePyramiding` and ensure only single unit entries occur.
      * **Zero ATR:** While unlikely in real data, ensure division by zero isn't a runtime error if `atr` becomes 0 (Pine Script's `na` checks usually handle this, but worth noting the logic's robustness). The `if atr > 0` checks are good.
      * **Rapid Price Movement:** Observe how zones and stop loss lines react to sudden spikes or drops.
      * **Long-running Trades:** Ensure zones continue to extend correctly and trailing stops update over extended periods.
      * **Short-running Trades:** Verify quick entries/exits correctly finalize and store historical zones.

-----

### 6\. Document Any New Issues Found

This section will be filled during the actual validation testing on TradingView. Any deviations from the `UI.mdc` or unexpected behavior will be logged here.

-----

### Critical Constraints Review:

  * **Maintain all Pine Script v6 type compliance fixes:** The proposed UI fix (adding `text` to `plotshape`) is a standard Pine Script v6 feature and does not introduce type conflicts.
  * **Never modify locked input parameters (lines 35-120):** No changes were made to these lines.
  * **Preserve existing zone management architecture:** The modifications for historical zones were merely ensuring they are correctly pushed and cleaned up, maintaining the existing `box` and `line` objects and array structures.
  * **Keep conditional plotshape approach for arrows:** The `plotshape` calls were merely enhanced, not fundamentally changed.
  * **Maintain performance and memory efficiency:** The `box` and `line` objects are actively managed with `array.shift` and `box.delete`/`line.delete`, which is Pine Script's recommended way for memory efficiency with many drawing objects. The number of historical zones is capped by user input.

-----

### Expected Deliverables Summary:

  * **Fully functional UI matching UI.mdc specifications:** The proposed fix for tier labels, once implemented and validated, will complete the UI compliance.
  * **Validated strategy logic with confirmed signals:** This will be confirmed through the TradingView backtesting process.
  * **All user controls working properly:** This will be confirmed through manual testing of input parameters.
  * **Documentation of any remaining issues:** To be populated during validation.
  * **Performance verification across timeframes:** To be observed during TradingView backtesting.

-----

### ACTION: Implemented UI fix for Tier Labels and prepared for validation.

Below is the modified Pine Script code with the UI fix for displaying tier labels.

```pinescript
// SCRIPT:// © 2025 JON Systems - SIMPLE VERSION
//@version=6
strategy("JON - Simple Trend Following Strategy",
      shorttitle="JON-SIMPLE",
      overlay=true,
      pyramiding=4,
      default_qty_type=strategy.fixed,
      initial_capital=40000,
      currency=currency.USD,
      commission_type=strategy.commission.percent,
      commission_value=0.1)

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                 S T R A T E G Y  I N F O R M A T I O N                       |
// ——————————————————————————————————————————————————————————————————————————————————————————————
// JON Simple Strategy - Jerry Parker inspired trend following system
//
// Core Philosophy:
// - Simple and Robust: Works across all markets and timeframes
// - Rolling Donchian Breakouts: No complex calendar monthly data
// - Advanced Risk Management: Correlation logic and dynamic adjustments
// - Sophisticated Exit System: Multi-unit trailing stops
// - Jerry Parker Entry + Modern Risk Management
//
// Entry Triggers (SIMPLIFIED):
// 1. Donchian Breakout: Close above 20-day high + ATR buffer
// 2. Dip Recovery: Close above 20-day low + larger ATR buffer (mean reversion)
//
// Risk Management (PRESERVED):
// - 1% risk per unit, max 4% total trade risk (4 units max)
// - 5 ATR initial stop loss with correlation logic
// - Dynamic ATR-based trailing stops (volatility responsive)
// - 1 ATR spacing between pyramid units
// - Individual stops initially, unified trailing at 5 ATR profit

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  I N P U T  P A R A M E T E R S                            |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- F-1: TREND FILTER SETTINGS ---
trendFilterEnabled = input.bool(true, "Enable 200 SMA Trend Filter", group = "Trend Filter (F-1)")
trendSmaLength = input.int(200, "Trend SMA Length", minval = 50, maxval = 500, group = "Trend Filter (F-1)")

// --- F-2: BREAKOUT ENTRY SETTINGS ---
enableBreakoutEntry = input.bool(true, "Enable Breakout Entry", group = "Breakout Entry (F-2)")
donchianPeriod = input.int(20, "Donchian Period", minval = 10, maxval = 55, group = "Breakout Entry (F-2)")
breakoutBufferATR = input.float(0.1, "Breakout Buffer (ATR multiplier)", minval = 0.0, maxval = 0.5, step = 0.05, group = "Breakout Entry (F-2)")

// --- F-3: DIP BUY ENTRY SETTINGS ---
enableDipBuyEntry = input.bool(true, "Enable Dip Buy Entry", group = "Dip Buy Entry (F-3)")
dipRecoveryBufferATR = input.float(0.3, "Dip Recovery Buffer (ATR multiplier)", minval = 0.1, maxval = 0.5, step = 0.05, group = "Dip Buy Entry (F-3)")

// --- F-4: EXIT STRATEGY SETTINGS ---
exitMode = input.string("ATR Trail", "Exit Strategy Mode", options = ["ATR Trail"], group = "Exit Strategy (F-4)")
atrTrailMultiplier = input.float(5.0, "Trailing Distance x ATR", minval = 0.5, maxval = 10.0, step = 0.1, group = "Exit Strategy (F-4)")
trailStartProfitMultiplier = input.float(5.0, "Trailing Start at Profit x ATR", minval = 1.0, maxval = 20.0, step = 0.1, group = "Exit Strategy (F-4)")
enableDynamicTrail = input.bool(true, "Enable Dynamic Trail Adjustment", group = "Exit Strategy (F-4)")
volatilityLookback = input.int(14, "Volatility Reference Period", minval = 10, maxval = 50, group = "Exit Strategy (F-4)")

// --- R-1 & R-2: RISK MANAGEMENT SETTINGS ---
unitRiskPercent = input.float(1.0, "Risk Per Unit %", minval = 0.1, maxval = 2.0, step = 0.1, group = "Risk Management (R-1, R-2)")
maxTradeRiskPercent = input.float(4.0, "Max Total Trade Risk %", minval = 1.0, maxval = 8.0, step = 0.1, group = "Risk Management (R-1, R-2)")
atrLength = input.int(14, "ATR Length", minval = 5, maxval = 50, group = "Risk Management (R-1, R-2)")
stopLossMultiplier = input.float(5.0, "Initial Stop Loss x ATR", minval = 0.5, maxval = 10.0, step = 0.1, group = "Risk Management (R-1, R-2)")
correlateAdditionalUnits = input.bool(true, "Correlate Additional Units", group = "Risk Management (R-1, R-2)")
correlateUnit1TrailSL = input.bool(true, "Correlate Unit 1 Trail SL", group = "Risk Management (R-1, R-2)")

// --- R-4: PYRAMIDING ENGINE SETTINGS ---
enablePyramiding = input.bool(true, "Enable Unit Pyramiding", group = "Pyramiding Engine (R-4)")
maxPyramidEntries = input.int(3, "Max Additional Units (Total: 4)", minval = 1, maxval = 4, group = "Pyramiding Engine (R-4)")
pyramidSpacingATR = input.float(1.0, "Unit Spacing (ATR multiplier)", minval = 0.5, maxval = 2.0, step = 0.5, group = "Pyramiding Engine (R-4)")
trailSLOnPyramiding = input.bool(true, "Trail SL on Unit Additions", group = "Pyramiding Engine (R-4)")

// --- UI: DISPLAY SETTINGS ---
showTrendSma = input.bool(true, "Show 200 SMA", group = "Display Settings")
showStopLevels = input.bool(true, "Show Stop Loss Levels", group = "Display Settings")
showEntryArrows = input.bool(true, "Show Entry Arrows", group = "Display Settings")
showExitArrows = input.bool(true, "Show Exit Arrows", group = "Display Settings")
showTierLabels = input.bool(true, "Show Tier-Function Labels", group = "Display Settings")
arrowSize = input.string("Small", "Arrow Size", options = ["Small", "Normal", "Large"], group = "Display Settings")
showProfitZone = input.bool(true, "Show Profit Zone", group = "Display Settings")
showRiskZone = input.bool(true, "Show Risk Zone", group = "Display Settings")
showStopLossLine = input.bool(true, "Show Stop Loss Line", group = "Display Settings")
showHistoricalZones = input.bool(true, "Show Historical Zones", group = "Display Settings")
zoneTransparency = input.int(85, "Zone Transparency", minval = 80, maxval = 95, group = "Display Settings")
maxHistoricalZones = input.int(50, "Max Historical Zones", minval = 10, maxval = 100, group = "Display Settings")

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  C O R E  I N D I C A T O R S                              |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Basic indicators
atr = ta.atr(atrLength)
trendSma = ta.sma(close, trendSmaLength)

// Trend filter
isTrendBullish = not trendFilterEnabled or close > trendSma

// Rolling Donchian channels (Jerry Parker style)
donchianHigh = ta.highest(high, donchianPeriod)
donchianLow = ta.lowest(low, donchianPeriod)

// Historical data sufficiency check
maxLookbackRequired = math.max(trendSmaLength, atrLength, donchianPeriod, volatilityLookback)
historicalDataSufficient = bar_index >= maxLookbackRequired

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  E N T R Y  T R I G G E R S                                |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Secondary Entry Triggers (either can fire)
breakoutTrigger = enableBreakoutEntry and close > (donchianHigh[1] + atr * breakoutBufferATR)
dipRecoveryTrigger = enableDipBuyEntry and close > (donchianLow[1] + atr * dipRecoveryBufferATR)

// Combined entry condition: PRIMARY filter AND (any SECONDARY trigger)
entryCondition = isTrendBullish and (breakoutTrigger or dipRecoveryTrigger)



// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    R I S K  M A N A G E M E N T                            |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Position sizing calculation
unitRiskAmountDollars = strategy.equity * (unitRiskPercent / 100.0)

// Dynamic volatility adjustment for trailing stops
avgAtr = ta.sma(atr, volatilityLookback)
volatilityAdjustment = enableDynamicTrail and not na(avgAtr) and avgAtr > 0 and not na(atr) and atr > 0 ?
                                 (atr / avgAtr > 1.2 ? 1.3 : atr / avgAtr < 0.8 ? 0.7 : 1.0) : 1.0

// Adjusted trail multiplier with dynamic volatility
adjustedAtrTrailMultiplier = atrTrailMultiplier * volatilityAdjustment

// @function Calculate position size based on ATR risk
calculateUnitSize(entryPrice, stopLossPrice) =>
    if na(entryPrice) or na(stopLossPrice) or entryPrice <= 0 or stopLossPrice <= 0 or
       unitRiskAmountDollars <= 0 or strategy.equity <= 0
        0.0
    else
        riskPerShare = math.abs(entryPrice - stopLossPrice)
        if riskPerShare <= 0
            0.0
        else
            unitValue = unitRiskAmountDollars / riskPerShare
            maxUnitValue = strategy.equity * 0.95 // Max 95% of equity
            validUnitValue = math.min(unitValue, maxUnitValue)
            math.floor(validUnitValue) // Round down to whole units

// @function Calculate ATR-based stop loss
calculateInitialStopLoss(entryPrice) =>
    if na(entryPrice) or entryPrice <= 0 or na(atr) or atr <= 0
        na
    else
        // Simple ATR stop loss
        atrStopPrice = entryPrice - (atr * stopLossMultiplier)
        
        // Final safety validation - ensure stop is below entry price
        math.min(atrStopPrice, entryPrice * 0.95) // Never closer than 5%

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    E X I T  S T R A T E G Y                                |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Exit tracking variables
var float currentStopPrice = na
var float atrTrailStop = na
var float atrTrailHigh = na
var bool trailStartActivated = false
var float profitActivationLevel = na
var float initialStopPrice = na

// Update exit system (PRESERVED ORIGINAL LOGIC)
if strategy.position_size > 0 and not na(atr)
    entryPrice = strategy.position_avg_price
    currentProfit = close - entryPrice
    profitInATR = atr > 0 ? currentProfit / atr : 0.0
    
    // Initialize initial stop price tracking
    if na(initialStopPrice) and not na(currentStopPrice)
        initialStopPrice := currentStopPrice
    
    if exitMode == "ATR Trail"
        // Calculate profit activation level for trailing (only set once)
        if na(profitActivationLevel)
            profitActivationLevel := entryPrice + (atr * trailStartProfitMultiplier)
        
        // Check if trailing should start
        if not trailStartActivated
            // Start trailing when profit threshold is reached
            if close >= profitActivationLevel
                trailStartActivated := true
                atrTrailHigh := close
        
        // Update trailing stop if activated
        if trailStartActivated
            // Update trail high on new highs
            if high > atrTrailHigh
                atrTrailHigh := high
            
            // Calculate new trailing stop using dynamic adjustment
            newTrailStop = atrTrailHigh - (atr * adjustedAtrTrailMultiplier)
            
            // Ensure trailing stop never moves down
            if na(atrTrailStop)
                atrTrailStop := newTrailStop
            else
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
            
            // Apply Unit 1 trail correlation if enabled
            if correlateUnit1TrailSL
                atrTrailStop := math.max(atrTrailStop, currentStopPrice)
            
            currentStopPrice := math.max(currentStopPrice, atrTrailStop)
else
    // Reset when no position
    currentStopPrice := na
    atrTrailStop := na
    atrTrailHigh := na
    trailStartActivated := false
    profitActivationLevel := na
    initialStopPrice := na

// Exit conditions
stopLossHit = strategy.position_size > 0 and not na(currentStopPrice) and low <= currentStopPrice
trendFilterFail = strategy.position_size > 0 and not isTrendBullish

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  T R A D E  E X E C U T I O N                              |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Pyramiding tracking (Tier System)
var int currentTierCount = 0
var float lastTierPrice = na

// Entry/Exit type tracking for UI labels
var string lastEntryType = na
var string lastExitType = na
var int lastEntryTier = na
var int lastExitTier = na

// Historical zone tracking (stores ALL past trades + current active trade)
var array<box> historicalProfitZones = array.new<box>()
var array<box> historicalRiskZones = array.new<box>()
var array<line> historicalStopLossLines = array.new<line>()

// Current active trade zone tracking
var box currentProfitZone = na
var box currentRiskZone = na
var line currentStopLossLine = na
var int tradeStartBar = na
var float tradeEntryPrice = na
var float tradeExitPrice = na

// Entry execution
if strategy.position_size == 0 and entryCondition and not na(atr) and atr > 0 and historicalDataSufficient
    initialStop = calculateInitialStopLoss(close)
    if not na(initialStop) and initialStop < close
        unitSize = calculateUnitSize(close, initialStop)
        if unitSize > 0
            // Determine entry type for UI labeling
            entryType = breakoutTrigger ? "F2" : dipRecoveryTrigger ? "F3" : "F2"
            
            strategy.entry("Tier 1 Long", strategy.long, qty=unitSize)
            currentStopPrice := initialStop
            currentTierCount := 0
            lastTierPrice := na
            
            // Track entry for UI labels
            lastEntryType := entryType
            lastEntryTier := 1
            
            // Initialize trade tracking for zones
            tradeStartBar := bar_index
            tradeEntryPrice := close

// Pyramiding execution (TIER SYSTEM LOGIC)
if enablePyramiding and strategy.position_size > 0 and currentTierCount < maxPyramidEntries and not na(atr) and atr > 0
    // Calculate profit in ATR terms
    entryPrice = strategy.position_avg_price
    profitInN = atr > 0 ? (close - entryPrice) / atr : 0.0
    
    // ATR threshold for next tier
    nextTierThreshold = (currentTierCount + 1) * pyramidSpacingATR
    
    // Check conditions for adding tiers
    atrThresholdMet = profitInN >= nextTierThreshold
    priceDistanceOk = na(lastTierPrice) or math.abs(close - lastTierPrice) >= (atr * pyramidSpacingATR)
    pyramidCondition = atrThresholdMet and priceDistanceOk
    
    // Risk check: ensure we don't exceed max trade risk
    currentTradeRisk = strategy.equity > 0 ?
                         (strategy.position_size * math.abs(strategy.position_avg_price - currentStopPrice) / strategy.equity * 100) :
                         100.0  // If equity is 0 or negative, assume max risk
    wouldExceedMaxRisk = currentTradeRisk + unitRiskPercent > maxTradeRiskPercent
    
    if pyramidCondition and not wouldExceedMaxRisk
        // Calculate stop for additional tier
        tierStopPrice = calculateInitialStopLoss(close)
        
        // Apply correlation logic for additional tiers
        if correlateAdditionalUnits
            tierStopPrice := math.max(tierStopPrice, currentStopPrice)
        
        tierSize = calculateUnitSize(close, tierStopPrice)
        
        if tierSize > 0
            // Determine entry type for additional tier
            entryType = breakoutTrigger ? "F2" : dipRecoveryTrigger ? "F3" : "F2"
            tierNumber = currentTierCount + 2
            tierId = "Tier " + str.tostring(tierNumber) + " Long"
            
            strategy.entry(tierId, strategy.long, qty=tierSize)
            currentTierCount := currentTierCount + 1
            lastTierPrice := close
            
            // Track entry for UI labels
            lastEntryType := entryType
            lastEntryTier := tierNumber
            
            // Update stop to protect new tier with correlation
            if correlateAdditionalUnits
                currentStopPrice := math.max(currentStopPrice, tierStopPrice)
            else
                currentStopPrice := tierStopPrice
            
            // Update trailing stop logic for additional tiers if enabled
            if trailSLOnPyramiding and trailStartActivated
                newTrailStop = atrTrailHigh - (atr * adjustedAtrTrailMultiplier)
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
                currentStopPrice := math.max(currentStopPrice, atrTrailStop)

// Exit execution (WHEN TRAILING STOP IS HIT, ALL POSITIONS EXIT)
if stopLossHit
    // Track exit type for UI labeling
    lastExitType := "F4"  // Trailing stop exit
    lastExitTier := currentTierCount + 1  // Current total tiers
    strategy.close_all(comment="Trailing Stop Hit")
else if trendFilterFail
    // Track exit type for UI labeling
    lastExitType := "F1"  // Trend filter exit
    lastExitTier := currentTierCount + 1  // Current total tiers
    strategy.close_all(comment="Trend Filter Fail")

// Reset tracking on position close
if strategy.position_size == 0
    currentTierCount := 0
    lastTierPrice := na
    // Reset UI label tracking after trade closes and labels have been shown
    lastEntryType := na
    lastEntryTier := na
    lastExitType := na
    lastExitTier := na


// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                 H I S T O R I C A L  Z O N E  M A N A G E M E N T                        |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Zone colors with user-configurable transparency
PROFIT_ZONE_COLOR = color.new(color.green, zoneTransparency)
RISK_ZONE_COLOR = color.new(color.red, zoneTransparency)
DARK_RED_LINE = color.new(color.red, 0)

// Historical zone constants (user-configurable)
MAX_ZONES = maxHistoricalZones  // Maximum historical zones to keep (memory management)

// Zone array memory management
// Clean up oldest zones if approaching limits
if array.size(historicalProfitZones) > MAX_ZONES
    oldBox = array.shift(historicalProfitZones)
    if not na(oldBox)
        box.delete(oldBox)

if array.size(historicalRiskZones) > MAX_ZONES
    oldBox = array.shift(historicalRiskZones)
    if not na(oldBox)
        box.delete(oldBox)

if array.size(historicalStopLossLines) > MAX_ZONES
    oldLine = array.shift(historicalStopLossLines)
    if not na(oldLine)
        line.delete(oldLine)

// Zone management for ACTIVE trades (with validation per pinescriptrules.txt)
if strategy.position_size > 0 and not na(currentStopPrice) and not na(tradeStartBar) and currentStopPrice > 0
    // Calculate zone boundaries (with safety validation)
    currentPrice = close
    upperBound = high > 0 ? high * 1.05 : close * 1.05  // Dynamic upper bound with validation
    lowerBound = currentStopPrice
    
    // Current Profit Zone: Current price to upper chart area (with validation)
    if showProfitZone and upperBound > currentPrice and tradeStartBar <= bar_index
        // Delete existing current profit zone
        if not na(currentProfitZone)
            box.delete(currentProfitZone)
        
        // Create new profit zone with validation (per pinescriptrules.txt error prevention)
        currentProfitZone := box.new(left=tradeStartBar, top=upperBound, right=bar_index, bottom=currentPrice, bgcolor=PROFIT_ZONE_COLOR, border_color=color.new(color.green, 50), border_width=1, extend=extend.right)
    
    // Current Risk Zone: Current price to stop loss (with validation)
    if showRiskZone and currentPrice > lowerBound and lowerBound > 0 and tradeStartBar <= bar_index
        // Delete existing current risk zone
        if not na(currentRiskZone)
            box.delete(currentRiskZone)
        
        // Create new risk zone with validation (per pinescriptrules.txt error prevention)
        currentRiskZone := box.new(left=tradeStartBar, top=currentPrice, right=bar_index, bottom=lowerBound, bgcolor=RISK_ZONE_COLOR, border_color=color.new(color.red, 50), border_width=1, extend=extend.right)
    
    // Current Stop Loss Line: Continuous line across trade duration (with validation)
    if showStopLossLine and currentStopPrice > 0 and tradeStartBar <= bar_index
        // Delete existing current stop loss line
        if not na(currentStopLossLine)
            line.delete(currentStopLossLine)
        
        // Create new stop loss line with validation (per pinescriptrules.txt error prevention)
        currentStopLossLine := line.new(x1=tradeStartBar, y1=currentStopPrice, x2=bar_index, y2=currentStopPrice, color=DARK_RED_LINE, width=2, extend=extend.right, style=line.style_solid)

// Handle trade EXIT - finalize zones and preserve them historically
if strategy.position_size == 0 and strategy.position_size[1] > 0
    // Trade just closed - finalize the zones
    tradeExitPrice := close
    
    // Finalize zones inline (no functions modifying global variables)
    if showHistoricalZones
        // Preserve zones historically
        if not na(currentProfitZone) and showProfitZone
            // Update current profit zone with final boundaries
            box.set_right(currentProfitZone, bar_index)
            box.set_bottom(currentProfitZone, tradeEntryPrice) // Profit zone from entry to upper, but historical should be entry to exit (if profit) or entry to stop (if loss)
            // Re-evaluate: UI.mdc says "Profit/Risk zones during active trades", "Historical zone preservation".
            // If it's a profit, profit zone should be entry to exit. If it's a loss, profit zone is not relevant.
            // Let's preserve the *initial* profit and risk zones as they were on entry, and just set their right boundary.
            // For profit zones, let's keep it from entry price to upper bound when active,
            // but for historical, it should represent the actual profit or range that was possible.
            // For simplicity and to match common interpretation: historical profit zone shows range from tradeEntryPrice to tradeExitPrice *if* positive,
            // or original upper bound with right boundary set.
            // Let's stick to the current logic which retains the box as it was created but sets the right edge.
            array.push(historicalProfitZones, currentProfitZone)
            currentProfitZone := na
        
        if not na(currentRiskZone) and showRiskZone
            // Update current risk zone with final boundaries
            box.set_right(currentRiskZone, bar_index)
            box.set_top(currentRiskZone, tradeEntryPrice) // Risk zone from entry to stop, but historical should just finalize right boundary.
            array.push(historicalRiskZones, currentRiskZone)
            currentRiskZone := na
        
        if not na(currentStopLossLine) and showStopLossLine
            // Update current stop loss line with final endpoint
            line.set_x2(currentStopLossLine, bar_index)
            array.push(historicalStopLossLines, currentStopLossLine)
            currentStopLossLine := na
    
    if not showHistoricalZones
        // Delete current zones if not preserving historically
        if not na(currentProfitZone)
            box.delete(currentProfitZone)
            currentProfitZone := na
        if not na(currentRiskZone)
            box.delete(currentRiskZone)
            currentRiskZone := na
        if not na(currentStopLossLine)
            line.delete(currentStopLossLine)
            currentStopLossLine := na
    
    // Reset current trade tracking
    tradeStartBar := na
    tradeEntryPrice := na

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  V I S U A L  I N T E R F A C E                            |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// UI Colors (per UI.mdc specification)
BRIGHT_BLUE = color.new(#0080FF, 0)
BRIGHT_ORANGE = color.new(#FF8000, 0)
PROFESSIONAL_BLUE = color.new(color.blue, 20)
SUBTLE_GREEN = color.new(color.green, 97)

// Essential plots
plot(showTrendSma ? trendSma : na, "200 SMA", color=PROFESSIONAL_BLUE, linewidth=1)

// Entry/Exit detection patterns (per pinescriptrules.txt standards)
entryDetected = strategy.position_size > 0 and strategy.position_size[1] == 0
exitDetected = strategy.position_size == 0 and strategy.position_size[1] > 0

// Generate strategic labels (F-2, F-3, F-4 format per JON standards)
// Only show labels if the toggle is on and a valid label exists
entryLabel = showTierLabels and not na(lastEntryType) and not na(lastEntryTier) ? "T" + str.tostring(lastEntryTier) + "-" + lastEntryType : ""
exitLabel = showTierLabels and not na(lastExitType) and not na(lastExitTier) ? "T" + str.tostring(lastExitTier) + "-" + lastExitType : ""


// Conditional arrow plotting with different sizes and labels
// Small arrows
plotshape(showEntryArrows and entryDetected and arrowSize == "Small", "Entry Small", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.small, text=entryLabel, textcolor=BRIGHT_BLUE)
plotshape(showExitArrows and exitDetected and arrowSize == "Small", "Exit Small", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.small, text=exitLabel, textcolor=BRIGHT_ORANGE)

// Normal arrows
plotshape(showEntryArrows and entryDetected and arrowSize == "Normal", "Entry Normal", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.normal, text=entryLabel, textcolor=BRIGHT_BLUE)
plotshape(showExitArrows and exitDetected and arrowSize == "Normal", "Exit Normal", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.normal, text=exitLabel, textcolor=BRIGHT_ORANGE)

// Large arrows
plotshape(showEntryArrows and entryDetected and arrowSize == "Large", "Entry Large", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.large, text=entryLabel, textcolor=BRIGHT_BLUE)
plotshape(showExitArrows and exitDetected and arrowSize == "Large", "Exit Large", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.large, text=exitLabel, textcolor=BRIGHT_ORANGE)


// Background colors for trade zones (per pinescriptrules.txt standards)
positionZone = strategy.position_size > 0
bgcolor(showStopLevels and positionZone ? SUBTLE_GREEN : na, title="Position Status")
```