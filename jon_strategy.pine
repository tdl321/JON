//@version=6
strategy("JON - Robust Trading Strategy",
     shorttitle="JON",
     overlay=true,
     pyramiding=3,
     // FIX: Changed default_qty_type to 'fixed' to allow our manual position sizing to work.
     // The original 'percent_of_equity' setting overrode all our custom risk logic.
     default_qty_type=strategy.fixed,
     initial_capital=100000,
     currency=currency.USD,
     commission_type=strategy.commission.percent,
     commission_value=0.1)

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                S T R A T E G Y   I N F O R M A T I O N                       |
// ——————————————————————————————————————————————————————————————————————————————————————————————
// JON Strategy - A robust, multi-asset trading system designed for superior risk-adjusted returns
//
// Core Philosophy:
// - Automate Everything: Full algorithmic execution without manual intervention
// - Robustness over Optimization: Works across multiple asset classes and market conditions
// - Sidestep Bear Markets: Preserves capital during major downturns
// - Low-Frequency Investing: High-quality signals, typically <1 trade per month per asset
//
// PRIMARY ENHANCEMENTS (Latest Update):
// - Monthly Timeframe Triggers: Both dip buy and breakout entries use monthly highs/lows
// - Precise Age Requirements: Min/max age validation for monthly reference points
// - Advanced Trailing System: Profit-activated trailing with "on touch high" option
// - Enhanced Correlation Logic: T1/T2 correlation features for entries and stops
// - Reward:Risk Ratio: 25:1 target with sophisticated stop management
//
// Primary Assets: BTCUSD, NDX/QQQ, XAUUSD (with CRYPTOCAP:TOTAL reference filter)
// Strategy Type: Monthly trend-following with dual entry system and profit-activated trailing
// Risk Management: ATR-based position sizing with correlated stops and 25:1 R:R target

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  I N P U T   P A R A M E T E R S                           |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- F-1: TREND FILTER SETTINGS ---
trendFilterEnabled = input.bool(true, "Enable 200 SMA Trend Filter", group = "Trend Filter (F-1)")
trendSmaLength = input.int(200, "Trend SMA Length", minval = 50, maxval = 500, group = "Trend Filter (F-1)")
useReferenceAsset = input.bool(true, "Use Reference Asset Filter", group = "Trend Filter (F-1)")
referenceSymbol = input.symbol("CRYPTOCAP:TOTAL", "Reference Asset Symbol", group = "Trend Filter (F-1)")

// --- F-2: BREAKOUT ENTRY SETTINGS ---
enableBreakoutEntry = input.bool(true, "Enable Breakout Entry", group = "Breakout Entry (F-2)")
breakoutTimeframe = input.string("1M", "Breakout Timeframe (Monthly)", options = ["1D", "1W", "1M"], group = "Breakout Entry (F-2)")
breakoutCrossWithinDays = input.int(20, "Cross Above Within (days)", minval = 1, maxval = 60, group = "Breakout Entry (F-2)")
breakoutMinAgeDays = input.int(20, "Min Age of Crossed High (days)", minval = 1, maxval = 100, group = "Breakout Entry (F-2)")
breakoutMaxAgeDays = input.int(200, "Max Age of Crossed High (days)", minval = 5, maxval = 500, group = "Breakout Entry (F-2)")

// --- F-3: DIP BUY ENTRY SETTINGS ---
enableDipBuyEntry = input.bool(true, "Enable Dip Buy Entry", group = "Dip Buy Entry (F-3)")
dipBuyTimeframe = input.string("1M", "Dip Buy Timeframe (Monthly)", options = ["1D", "1W", "1M"], group = "Dip Buy Entry (F-3)")
dipRecoveryWithinDays = input.int(30, "Recovery Within (days)", minval = 1, maxval = 90, group = "Dip Buy Entry (F-3)")
dipMinAgeDays = input.int(15, "Min Age of Crossed Low (days)", minval = 1, maxval = 100, group = "Dip Buy Entry (F-3)")
dipMaxAgeDays = input.int(90, "Max Age of Crossed Low (days)", minval = 5, maxval = 200, group = "Dip Buy Entry (F-3)")

// --- F-4: EXIT STRATEGY SETTINGS ---
exitMode = input.string("ATR Trail", "Exit Strategy Mode", options = ["ATR Trail", "Aggressive Profit Take"], group = "Exit Strategy (F-4)")
atrTrailMultiplier = input.float(20.0, "Trailing Distance x ATR", minval = 0.5, maxval = 50.0, step = 0.1, group = "Exit Strategy (F-4)")
aggressiveProfitTarget = input.float(10.0, "Aggressive Profit Target %", minval = 1.0, maxval = 50.0, step = 0.5, group = "Exit Strategy (F-4)")
trailStartProfitMultiplier = input.float(5.0, "Trailing Start at Profit x ATR", minval = 1.0, maxval = 20.0, step = 0.1, group = "Exit Strategy (F-4)")
trailOnTouchHigh = input.bool(true, "Trail Start on Touch High", group = "Exit Strategy (F-4)")

// --- F-5: OPPORTUNISTIC EXIT SETTINGS ---
enableOpportunisticExit = input.bool(true, "Enable Opportunistic Exit", group = "Opportunistic Exit (F-5)")
failedBreakoutBars = input.int(10, "Failed Breakout Timeout (bars)", minval = 3, maxval = 50, group = "Opportunistic Exit (F-5)")

// --- R-1 & R-2: RISK MANAGEMENT SETTINGS ---
riskPercent = input.float(3.0, "Risk Per Trade %", minval = 0.1, maxval = 10.0, step = 0.1, group = "Risk Management (R-1, R-2)")
atrLength = input.int(14, "ATR Length", minval = 5, maxval = 50, group = "Risk Management (R-1, R-2)")
stopLossMultiplier = input.float(5.0, "Initial Stop Loss x ATR", minval = 0.5, maxval = 20.0, step = 0.1, group = "Risk Management (R-1, R-2)")
rewardRiskRatio = input.float(25.0, "Reward:Risk Ratio", minval = 1.0, maxval = 50.0, step = 0.5, group = "Risk Management (R-1, R-2)")
correlateT1 = input.bool(true, "Correlate T1 Entry", group = "Risk Management (R-1, R-2)")
correlateT2 = input.bool(true, "Correlate T2 Entry", group = "Risk Management (R-1, R-2)")
correlateT1TrailSL = input.bool(true, "Correlate T1 Trail SL", group = "Risk Management (R-1, R-2)")
minSLDist = input.bool(true, "Min SL Distance", group = "Risk Management (R-1, R-2)")

// --- R-4: PYRAMIDING ENGINE SETTINGS ---
enablePyramiding = input.bool(true, "Enable Tiered Pyramiding", group = "Pyramiding Engine (R-4)")
maxPyramidEntries = input.int(2, "Max Pyramid Tiers (Total: 3)", minval = 1, maxval = 3, group = "Pyramiding Engine (R-4)")
minTierSpacing = input.float(2.0, "Min Tier Price Spacing %", minval = 0.5, maxval = 10.0, step = 0.5, group = "Pyramiding Engine (R-4)")
trailSLOnPyramiding = input.bool(true, "Trail SL on Pyramiding T2 Entry", group = "Pyramiding Engine (R-4)")

// --- UI-1 & UI-2: DISPLAY SETTINGS ---
showTrendSma = input.bool(true, "Show 200 SMA", group = "Display Settings (UI-1, UI-2)")
showStopLevels = input.bool(true, "Show Stop Loss Levels", group = "Display Settings (UI-1, UI-2)")
showTradeLabels = input.bool(true, "Show Trade Entry/Exit Labels", group = "Display Settings (UI-1, UI-2)")
showDebugInfo = input.bool(false, "Show Debug Info", group = "Display Settings (UI-1, UI-2)")

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    C O R E   I N D I C A T O R S                           |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- PRIMARY ASSET INDICATORS ---
trendSma = ta.sma(close, trendSmaLength)
isTrendBullish = not trendFilterEnabled or close > trendSma
atr = ta.atr(atrLength)
isDataValid = not na(close) and not na(atr) and atr > 0 and strategy.equity > 0

// --- REFERENCE ASSET INDICATORS ---
referenceClose = useReferenceAsset ? request.security(referenceSymbol, timeframe.period, close) : na
// Fix: Extract ta.sma call from conditional scope for consistency
referenceSmaValue = useReferenceAsset and not na(referenceClose) ? ta.sma(referenceClose, trendSmaLength) : na
referenceSma = referenceSmaValue
isReferenceBullish = not useReferenceAsset or (not na(referenceSma) and referenceClose > referenceSma)

// --- FINAL TREND FILTER VALIDATION ---
isTrendFilterPassed = isTrendBullish and isReferenceBullish

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  S I G N A L   D E T E C T I O N                             |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- F-2: BREAKOUT ENTRY ---
// Get monthly data series (fixed approach to avoid loop variable issues)
monthlyHigh = request.security(syminfo.tickerid, breakoutTimeframe, high, lookahead=barmerge.lookahead_off)
monthlyTime = request.security(syminfo.tickerid, breakoutTimeframe, time, lookahead=barmerge.lookahead_off)

// Get historical monthly data using ta.valuewhen approach
var float validMonthlyHigh = na
var int validMonthlyHighAge = na

if (enableBreakoutEntry)
    // Find the highest monthly high within the age range
    currentTime = time
    validHighFound = false
    
    // Look for a monthly high that's within our age criteria
    for i = 1 to 50 // Reasonable lookback for monthly data
        pastMonthlyHigh = monthlyHigh[i]
        pastMonthlyTime = monthlyTime[i]
        
        if not na(pastMonthlyHigh) and not na(pastMonthlyTime)
            ageDays = math.round((currentTime - pastMonthlyTime) / (24 * 60 * 60 * 1000))
            
            // Check if this high meets our age criteria
            if ageDays >= breakoutMinAgeDays and ageDays <= breakoutMaxAgeDays
                if not validHighFound or pastMonthlyHigh > validMonthlyHigh
                    validMonthlyHigh := pastMonthlyHigh
                    validMonthlyHighAge := ageDays
                    validHighFound := true

// Check if we crossed above the monthly high within specified days
isRecentHighValid = not na(validMonthlyHigh)
crossoverSignal = false
if isRecentHighValid
    // Check if we crossed above within the last N days
    crossedRecently = false
    for i = 0 to breakoutCrossWithinDays
        if high[i] > validMonthlyHigh
            crossedRecently := true
            break
    crossoverSignal := crossedRecently and close > validMonthlyHigh

breakoutEntryCondition = enableBreakoutEntry and isTrendFilterPassed and isDataValid and isRecentHighValid and crossoverSignal

// --- F-3: DIP BUY ENTRY ---
// Get monthly lows data
monthlyLow = request.security(syminfo.tickerid, dipBuyTimeframe, low, lookahead=barmerge.lookahead_off)
monthlyLowTime = request.security(syminfo.tickerid, dipBuyTimeframe, time, lookahead=barmerge.lookahead_off)

// Find valid monthly low that meets age criteria
var float validMonthlyLow = na
var int validMonthlyLowAge = na

if (enableDipBuyEntry)
    currentTime = time
    validLowFound = false
    
    // Look for a monthly low that's within our age criteria
    for i = 1 to 50 // Reasonable lookback for monthly data
        pastMonthlyLow = monthlyLow[i]
        pastMonthlyTime = monthlyLowTime[i]
        
        if not na(pastMonthlyLow) and not na(pastMonthlyTime)
            ageDays = math.round((currentTime - pastMonthlyTime) / (24 * 60 * 60 * 1000))
            
            // Check if this low meets our age criteria
            if ageDays >= dipMinAgeDays and ageDays <= dipMaxAgeDays
                if not validLowFound or pastMonthlyLow < validMonthlyLow
                    validMonthlyLow := pastMonthlyLow
                    validMonthlyLowAge := ageDays
                    validLowFound := true

// Check if we touched the monthly low and recovered within specified days  
isDipRecovering = false
if not na(validMonthlyLow)
    // Check if we touched the low recently
    touchedLow = false
    for i = 0 to dipRecoveryWithinDays
        if low[i] <= validMonthlyLow * 1.001 // Allow 0.1% tolerance for "touch"
            touchedLow := true
            break
    
    // Check if we're now recovering (close above the low)
    isDipRecovering := touchedLow and close > validMonthlyLow

dipBuyEntryCondition = enableDipBuyEntry and isTrendFilterPassed and isDataValid and isDipRecovering

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    R I S K   M A N A G E M E N T                             |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- R-1: POSITION SIZING ---
riskAmountDollars = strategy.equity * (riskPercent / 100.0)

// Fixed function definition for v6 - removed 'method' keyword
calculatePositionSize(entryPrice, stopLossPrice) =>
    if (na(entryPrice) or na(stopLossPrice) or riskAmountDollars <= 0)
        0.0
    else
        riskPerShare = math.abs(entryPrice - stopLossPrice)
        riskPerShare > 0 ? riskAmountDollars / riskPerShare : 0.0

// --- R-2: STOP LOSS ---
// Enhanced stop loss calculation with correlation features
calculateInitialStopLoss(entryPrice, entryType) =>
    // Base ATR stop loss
    atrStopPrice = entryPrice - (atr * stopLossMultiplier)
    
    // Get contextual reference levels
    recentSwingLow = ta.lowest(low, 10) * 0.995
    monthlyLowRef = not na(validMonthlyLow) ? validMonthlyLow * 0.99 : atrStopPrice
    
    // Apply correlation logic based on entry type
    finalStopPrice = atrStopPrice
    
    if entryType == "BREAKOUT"
        if correlateT1
            // For correlated T1 breakouts, use stricter of ATR or swing low
            finalStopPrice := math.min(atrStopPrice, recentSwingLow)
    else if entryType == "DIP_BUY"
        if correlateT1
            // For correlated T1 dip buys, use stricter of ATR or monthly low
            finalStopPrice := math.min(atrStopPrice, monthlyLowRef)
    
    // Apply minimum stop distance if enabled
    if minSLDist
        minDistancePrice = entryPrice * 0.98 // Minimum 2% stop distance
        finalStopPrice := math.min(finalStopPrice, minDistancePrice)
    
    finalStopPrice

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    E X I T   S T R A T E G Y                                 |
// ——————————————————————————————————————————————————————————————————————————————————————————————

var float currentStopPrice = na
var float atrTrailStop = na
var float atrTrailHigh = na
var float aggressiveProfitPrice = na
var bool trailStartActivated = false
var float profitActivationLevel = na

// --- F-4: ENHANCED EXIT SYSTEM UPDATE LOGIC ---
if strategy.position_size > 0
    entryPrice = strategy.position_avg_price
    currentProfit = close - entryPrice
    profitInATR = currentProfit / atr
    
    if exitMode == "ATR Trail"
        // Calculate profit activation level for trailing (only set once)
        if na(profitActivationLevel)
            profitActivationLevel := entryPrice + (atr * trailStartProfitMultiplier)
        
        // Check if trailing should start
        if not trailStartActivated
            if trailOnTouchHigh
                // Start trailing when we touch a new high after profit threshold
                if close >= profitActivationLevel and high > entryPrice + (atr * trailStartProfitMultiplier)
                    trailStartActivated := true
                    atrTrailHigh := high
            else
                // Start trailing immediately when profit threshold is reached
                if close >= profitActivationLevel
                    trailStartActivated := true
                    atrTrailHigh := close
        
        // Update trailing stop if activated
        if trailStartActivated
            // Update trail high on new highs
            if high > atrTrailHigh
                atrTrailHigh := high
            
            // Calculate new trailing stop
            newTrailStop = atrTrailHigh - (atr * atrTrailMultiplier)
            
            // Ensure trailing stop never moves down and respects correlation settings
            if na(atrTrailStop)
                atrTrailStop := newTrailStop
            else
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
            
            // Apply T1 trail correlation if enabled
            if correlateT1TrailSL
                atrTrailStop := math.max(atrTrailStop, currentStopPrice)
            
            currentStopPrice := math.max(currentStopPrice, atrTrailStop)
            
    else if exitMode == "Aggressive Profit Take"
        if na(aggressiveProfitPrice)
            aggressiveProfitPrice := entryPrice * (1 + aggressiveProfitTarget / 100)
else // No position open, reset all exit variables
    currentStopPrice := na
    atrTrailStop := na
    atrTrailHigh := na
    aggressiveProfitPrice := na
    trailStartActivated := false
    profitActivationLevel := na

// --- EXIT CONDITIONS ---
stopLossHit = strategy.position_size > 0 and not na(currentStopPrice) and low <= currentStopPrice
profitTargetHit = strategy.position_size > 0 and exitMode == "Aggressive Profit Take" and not na(aggressiveProfitPrice) and high >= aggressiveProfitPrice

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                             T R A D E   E X E C U T I O N   E N G I N E                      |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- F-5: OPPORTUNISTIC EXIT TRACKING ---
var float breakoutEntryPrice = na
var int breakoutEntryBar = na
var bool isBreakoutPosition = false

// --- R-4: PYRAMIDING TRACKING ---
var int currentPyramidCount = 0
var float lastPyramidPrice = na

// --- ENTRY EXECUTION ---
if (strategy.position_size == 0 and isDataValid)
    float initialStop = na
    float positionSize = na
    string entryId = ""

    if breakoutEntryCondition
        initialStop := calculateInitialStopLoss(close, "BREAKOUT")
        positionSize := calculatePositionSize(close, initialStop)
        entryId := "Breakout Long"
        // Track breakout entry for F-5 opportunistic exit
        breakoutEntryPrice := close
        breakoutEntryBar := bar_index
        isBreakoutPosition := true
    else if dipBuyEntryCondition
        initialStop := calculateInitialStopLoss(close, "DIP_BUY")
        positionSize := calculatePositionSize(close, initialStop)
        entryId := "Dip Buy Long"
        // Dip buy entries don't use opportunistic exit
        isBreakoutPosition := false

    if positionSize > 0
        strategy.entry(entryId, strategy.long, qty=positionSize)
        currentStopPrice := initialStop // Set the initial hard stop

// --- R-4: ENHANCED PYRAMIDING EXECUTION ---
if (enablePyramiding and strategy.position_size > 0 and currentPyramidCount < maxPyramidEntries)
    // Calculate current unrealized profit in dollars
    unrealizedProfitDollars = strategy.openprofit
    
    // Determine profit threshold needed for next tier
    tierProfitRequired = (currentPyramidCount + 1) * (strategy.equity * riskPercent / 100)
    
    // Check if we have enough profit to fund the next tier
    canAffordNextTier = unrealizedProfitDollars >= tierProfitRequired
    
    // Ensure we're not too close to last pyramid entry
    priceDistanceOk = na(lastPyramidPrice) or math.abs(close - lastPyramidPrice) / lastPyramidPrice > (minTierSpacing / 100)
    
    // Check for new entry signals while in position
    pyramidCondition = canAffordNextTier and priceDistanceOk and (breakoutEntryCondition or dipBuyEntryCondition)
    
    if pyramidCondition
        // Apply T2 correlation logic for pyramid entries
        entryType = isBreakoutPosition ? "BREAKOUT" : "DIP_BUY"
        pyramidStopPrice = calculateInitialStopLoss(close, entryType)
        
        // Enhanced correlation for T2 entries
        if correlateT2
            // For T2 entries, ensure stop correlates with current position
            pyramidStopPrice := math.max(pyramidStopPrice, currentStopPrice)
        
        pyramidSize = calculatePositionSize(close, pyramidStopPrice) // Full risk size, same as initial entry
        
        if pyramidSize > 0
            pyramidId = "Tier " + str.tostring(currentPyramidCount + 2) // Tier 2, Tier 3, etc.
            strategy.entry(pyramidId, strategy.long, qty=pyramidSize)
            currentPyramidCount := currentPyramidCount + 1
            lastPyramidPrice := close
            
            // Update stop to protect pyramid entry with correlation
            if correlateT2
                currentStopPrice := math.max(currentStopPrice, pyramidStopPrice)
            else
                currentStopPrice := pyramidStopPrice // Use new stop if not correlated
            
            // Update trailing stop logic for pyramid entries if enabled
            if trailSLOnPyramiding and trailStartActivated
                // Recalculate trailing stop to account for new entry
                newTrailStop = atrTrailHigh - (atr * atrTrailMultiplier)
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
                currentStopPrice := math.max(currentStopPrice, atrTrailStop)

// --- F-5: ENHANCED OPPORTUNISTIC EXIT CONDITIONS ---
failedBreakoutExit = false
if (enableOpportunisticExit and strategy.position_size > 0 and isBreakoutPosition and not na(breakoutEntryPrice) and not na(breakoutEntryBar))
    barsSinceEntry = bar_index - breakoutEntryBar
    
    // Extract ta.highest call from conditional scope for consistency
    highSinceEntry = ta.highest(high, barsSinceEntry)
    
    // F-5: Exit if breakout fails to make new high within timeout
    if barsSinceEntry >= failedBreakoutBars
        if highSinceEntry <= breakoutEntryPrice * 1.005 // No meaningful follow-through (0.5% threshold)
            failedBreakoutExit := true
    
    // F-5: Exit if close falls below entry with correlation consideration
    exitThreshold = correlateT1 ? breakoutEntryPrice * 0.98 : breakoutEntryPrice * 0.97
    if close < exitThreshold
        failedBreakoutExit := true
    
    // F-5: Exit if monthly high reference is lost (enhanced with age validation)
    if not na(validMonthlyHigh) and close < validMonthlyHigh * 0.995
        failedBreakoutExit := true

// --- EXIT EXECUTION ---
if strategy.position_size > 0
    if failedBreakoutExit
        strategy.close_all(comment="Failed Breakout")
    else if stopLossHit
        strategy.close_all(comment="Stop Loss / Trail Hit")
    else if profitTargetHit
        strategy.close_all(comment="Profit Target Hit")
    else if not isTrendFilterPassed
        strategy.close_all(comment="Trend Filter Fail (Bear Market)")

// --- RESET TRACKING ON POSITION CLOSE ---
if strategy.position_size == 0
    breakoutEntryPrice := na
    breakoutEntryBar := na
    isBreakoutPosition := false
    // Reset pyramiding tracking
    currentPyramidCount := 0
    lastPyramidPrice := na

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                V I S U A L   I N T E R F A C E (UI)                        |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- CLEAN TREND VISUALIZATION ---
// Only show SMA if enabled, with clean styling
plot(showTrendSma ? trendSma : na, "Trend Filter", 
     color = color.new(color.white, 30), 
     linewidth = 1)

// --- CLEAN STOP LEVELS ---
// Deep red stop loss line like in reference
plot(showStopLevels and strategy.position_size > 0 ? currentStopPrice : na, 
     "Hard Stop Loss", 
     color = color.new(color.red, 0), 
     style = plot.style_linebr, 
     linewidth = 2)

// --- ENHANCED TRADE SIGNALS WITH CONSOLIDATED LABELS ---
// Track entry and exit events with detailed info
var bool showBuySignal = false
var bool showSellSignal = false
var string buySignalText = ""
var string sellSignalText = ""
var string lastExitReason = ""

// --- PROFIT ACTIVATION LEVEL VISUALIZATION ---
plot(showStopLevels and strategy.position_size > 0 and not na(profitActivationLevel) ? profitActivationLevel : na, 
     "Profit Activation Level", 
     color = color.new(color.blue, 50), 
     style = plot.style_linebr, 
     linewidth = 1)

// Update signal flags and consolidated labels based on position changes
if strategy.position_size > 0 and strategy.position_size[1] == 0
    // Position just opened - create consolidated buy label
    showBuySignal := true
    showSellSignal := false
    
    // Determine entry type
    entryType = breakoutEntryCondition ? "Breakout" : dipBuyEntryCondition ? "Dip" : "Entry"
    buySignalText := "Buy (" + entryType + ")\n$" + str.tostring(close, "#,###")
    
else if strategy.position_size == 0 and strategy.position_size[1] > 0
    // Position just closed - create consolidated sell label
    showBuySignal := false
    showSellSignal := true
    
    // Calculate return
    avgPrice = strategy.position_avg_price[1]
    returnPct = avgPrice > 0 ? ((close - avgPrice) / avgPrice * 100) : 0
    returnStr = (returnPct >= 0 ? "+" : "") + str.tostring(returnPct, "#.#") + "%"
    
    // Use last known exit reason or default
    exitType = lastExitReason != "" ? lastExitReason : "Exit"
    sellSignalText := "Sell (" + exitType + ")\n$" + str.tostring(close, "#,###") + "\n" + returnStr
    
else
    // No position change
    showBuySignal := false
    showSellSignal := false

// Track exit reasons when they occur
if strategy.position_size == 0 and strategy.position_size[1] > 0
    if failedBreakoutExit
        lastExitReason := "Failed BO"
    else if stopLossHit
        lastExitReason := "Stop Loss"
    else if profitTargetHit
        lastExitReason := "Target"
    else if not isTrendFilterPassed
        lastExitReason := "Trend Fail"
    else
        lastExitReason := "Manual"

// PRIMARY SIGNALS - Clean minimal arrows only
plotshape(showTradeLabels and showBuySignal, 
          title="Buy Signal", 
          location=location.belowbar, 
          color=color.new(color.lime, 0), 
          style=shape.triangleup, 
          size=size.tiny)

plotshape(showTradeLabels and showSellSignal, 
          title="Sell Signal", 
          location=location.abovebar, 
          color=color.new(color.red, 0), 
          style=shape.triangledown, 
          size=size.tiny)

// --- GLOBAL SCOPE CALCULATIONS FOR DEBUG INDICATORS ---
// Calculate debug conditions at global scope to avoid local plotting issues
pyramidReadyCondition = showDebugInfo and enablePyramiding and strategy.position_size > 0 and currentPyramidCount < maxPyramidEntries and strategy.openprofit >= ((currentPyramidCount + 1) * (strategy.equity * riskPercent / 100))

// --- ALL PLOTTING FUNCTIONS AT GLOBAL SCOPE ---
// TRADE LABELS REMOVED FOR CLEANER CHART
// (Labels disabled - only keeping minimal arrow signals)

// DEBUG PLOTTING FUNCTIONS - All at global scope
// Pyramiding readiness indicator
plotshape(pyramidReadyCondition, title="Pyramid Ready", location=location.top, 
         color=color.new(color.yellow, 70), style=shape.circle, size=size.tiny)

// Clean trend filter background with better text positioning
bgcolor(showDebugInfo and not isTrendFilterPassed ? color.new(color.red, 95) : na, title="Bear Market")

// Entry condition indicators with better spacing
plotchar(showDebugInfo and breakoutEntryCondition, title="Breakout", char="↗", 
         location=location.belowbar, color=color.new(color.blue, 40), size=size.small)

plotchar(showDebugInfo and dipBuyEntryCondition, title="Dip Buy", char="↙", 
         location=location.belowbar, color=color.new(color.purple, 40), size=size.small)

// Monthly reference levels (debug)
plot(showDebugInfo and not na(validMonthlyHigh) ? validMonthlyHigh : na, 
     "Monthly High Reference", color=color.new(color.blue, 70), linewidth=1, style=plot.style_linebr)

plot(showDebugInfo and not na(validMonthlyLow) ? validMonthlyLow : na, 
     "Monthly Low Reference", color=color.new(color.purple, 70), linewidth=1, style=plot.style_linebr)

// Trailing activation indicator
plotshape(showDebugInfo and trailStartActivated and strategy.position_size > 0, 
          title="Trail Activated", location=location.top, color=color.new(color.orange, 60), 
          style=shape.diamond, size=size.tiny)

// --- PROPERLY ANCHORED RISK VISUALIZATION BOXES ---
// Advanced risk/reward visualization system with proper scaling

// Track position entry time for box anchoring
var int positionStartBar = na
var int positionEndBar = na
var box riskBox = na
var box rewardBox = na
var bool boxesCreated = false

// Update box anchoring when position opens
if strategy.position_size > 0 and strategy.position_size[1] == 0
    positionStartBar := bar_index
    positionEndBar := bar_index + 50  // Fixed width boxes
    boxesCreated := false

// Create boxes only once when position opens (not on every bar)
if strategy.position_size > 0 and not na(positionStartBar) and not boxesCreated
    entryPrice = strategy.position_avg_price
    stopPrice = currentStopPrice
    
    // Calculate upside target based on reward:risk ratio and exit mode
    rewardTarget = na(stopPrice) ? entryPrice + (atr * rewardRiskRatio) : entryPrice + (math.abs(entryPrice - stopPrice) * rewardRiskRatio)
    
    // Use aggressive profit target if that mode is selected
    if exitMode == "Aggressive Profit Take" and not na(aggressiveProfitPrice)
        rewardTarget := aggressiveProfitPrice
    
    // Create risk zone box (entry to stop loss) - only once
    if not na(stopPrice)
        riskBox := box.new(positionStartBar, math.min(entryPrice, stopPrice), positionEndBar, math.max(entryPrice, stopPrice), bgcolor=color.new(color.red, 85), border_color=color.new(color.red, 60), border_width=1, text="Risk Zone\n" + str.tostring(math.abs((entryPrice - stopPrice) / entryPrice * 100), "#.#") + "%", text_color=color.white, text_size=size.small)
    
    // Create reward zone box (entry to target) - only once
    if not na(rewardTarget)
        rewardBox := box.new(positionStartBar, math.min(entryPrice, rewardTarget), positionEndBar, math.max(entryPrice, rewardTarget), bgcolor=color.new(color.green, 85), border_color=color.new(color.green, 60), border_width=1, text="Reward Zone\n" + str.tostring((rewardTarget - entryPrice) / entryPrice * 100, "#.#") + "%", text_color=color.white, text_size=size.small)
    
    boxesCreated := true

// Clean up boxes when position closes
if strategy.position_size == 0 and strategy.position_size[1] > 0
    if not na(riskBox)
        box.delete(riskBox)
        riskBox := na
    if not na(rewardBox)
        box.delete(rewardBox)
        rewardBox := na
    positionStartBar := na
    positionEndBar := na
    boxesCreated := false

// Subtle background when not in position
bgcolor(strategy.position_size == 0 ? color.new(color.white, 98) : na)

// --- CLEAN PERFORMANCE DISPLAY ---
// Properly stacked information with no overlap
if barstate.islast and showTradeLabels
    var table infoTable = table.new(position.top_right, 2, 5, 
                                   bgcolor=color.new(color.white, 90), 
                                   border_width=1,
                                   border_color=color.new(color.gray, 60))
    
    // Calculate key metrics
    strategyReturn = (strategy.equity - strategy.initial_capital) / strategy.initial_capital * 100
    
    // Header row
    table.cell(infoTable, 0, 0, "JON Strategy", text_color=color.new(color.black, 0), 
               text_size=size.normal, bgcolor=color.new(color.blue, 80))
    table.cell(infoTable, 1, 0, "Status", text_color=color.white, 
               text_size=size.normal, bgcolor=color.new(color.blue, 80))
    
    // Performance metrics with better spacing
    table.cell(infoTable, 0, 1, "Return", text_color=color.new(color.black, 20), text_size=size.small)
    table.cell(infoTable, 1, 1, str.tostring(strategyReturn, "#.#") + "%", 
               text_color=strategyReturn > 0 ? color.green : color.red, text_size=size.small)
    
    table.cell(infoTable, 0, 2, "Trades", text_color=color.new(color.black, 20), text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(strategy.closedtrades), text_color=color.blue, text_size=size.small)
    
    table.cell(infoTable, 0, 3, "Win Rate", text_color=color.new(color.black, 20), text_size=size.small)
    winRate = strategy.closedtrades == 0 ? 0 : strategy.wintrades / strategy.closedtrades * 100
    table.cell(infoTable, 1, 3, str.tostring(winRate, "#") + "%", 
               text_color=winRate > 50 ? color.green : color.red, text_size=size.small)
    
    // Market condition and signal status
    marketStatus = not isTrendFilterPassed ? "BEAR" : "BULL"
    currentSignal = breakoutEntryCondition ? "BREAKOUT" : dipBuyEntryCondition ? "DIP BUY" : "WAIT"
    table.cell(infoTable, 0, 4, "Market", text_color=color.new(color.black, 20), text_size=size.small)
    table.cell(infoTable, 1, 4, marketStatus + " | " + currentSignal, 
               text_color=marketStatus == "BEAR" ? color.red : currentSignal == "WAIT" ? color.gray : color.blue, 
               text_size=size.small)