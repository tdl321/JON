// © 2025 JON Systems - SIMPLE VERSION
//@version=6
strategy("JON - Simple Trend Following Strategy",
     shorttitle="JON-SIMPLE",
     overlay=true,
     pyramiding=4,
     default_qty_type=strategy.fixed,
     initial_capital=40000,
     currency=currency.USD,
     commission_type=strategy.commission.percent,
     commission_value=0.1)

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                S T R A T E G Y   I N F O R M A T I O N                       |
// ——————————————————————————————————————————————————————————————————————————————————————————————
// JON Simple Strategy - Jerry Parker inspired trend following system
//
// Core Philosophy:
// - Simple and Robust: Works across all markets and timeframes
// - Rolling Donchian Breakouts: No complex calendar monthly data
// - Advanced Risk Management: Correlation logic and dynamic adjustments
// - Sophisticated Exit System: Multi-unit trailing stops
// - Jerry Parker Entry + Modern Risk Management
//
// Entry Triggers (SIMPLIFIED):
// 1. Donchian Breakout: Close above 20-day high + ATR buffer
// 2. Dip Recovery: Close above 20-day low + larger ATR buffer (mean reversion)
//
// Risk Management (PRESERVED):
// - 1% risk per unit, max 4% total trade risk (4 units max)
// - 5 ATR initial stop loss with correlation logic
// - Dynamic ATR-based trailing stops (volatility responsive)
// - 1 ATR spacing between pyramid units
// - Individual stops initially, unified trailing at 5 ATR profit

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  I N P U T   P A R A M E T E R S                           |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- F-1: TREND FILTER SETTINGS ---
trendFilterEnabled = input.bool(true, "Enable 200 SMA Trend Filter", group = "Trend Filter (F-1)")
trendSmaLength = input.int(200, "Trend SMA Length", minval = 50, maxval = 500, group = "Trend Filter (F-1)")

// --- F-2: BREAKOUT ENTRY SETTINGS ---
enableBreakoutEntry = input.bool(true, "Enable Breakout Entry", group = "Breakout Entry (F-2)")
donchianPeriod = input.int(20, "Donchian Period", minval = 10, maxval = 55, group = "Breakout Entry (F-2)")
breakoutBufferATR = input.float(0.1, "Breakout Buffer (ATR multiplier)", minval = 0.0, maxval = 0.5, step = 0.05, group = "Breakout Entry (F-2)")

// --- F-3: DIP BUY ENTRY SETTINGS ---
enableDipBuyEntry = input.bool(true, "Enable Dip Buy Entry", group = "Dip Buy Entry (F-3)")
dipRecoveryBufferATR = input.float(0.3, "Dip Recovery Buffer (ATR multiplier)", minval = 0.1, maxval = 0.5, step = 0.05, group = "Dip Buy Entry (F-3)")

// --- F-4: EXIT STRATEGY SETTINGS ---
exitMode = input.string("ATR Trail", "Exit Strategy Mode", options = ["ATR Trail"], group = "Exit Strategy (F-4)")
atrTrailMultiplier = input.float(5.0, "Trailing Distance x ATR", minval = 0.5, maxval = 10.0, step = 0.1, group = "Exit Strategy (F-4)")
trailStartProfitMultiplier = input.float(5.0, "Trailing Start at Profit x ATR", minval = 1.0, maxval = 20.0, step = 0.1, group = "Exit Strategy (F-4)")
enableDynamicTrail = input.bool(true, "Enable Dynamic Trail Adjustment", group = "Exit Strategy (F-4)")
volatilityLookback = input.int(14, "Volatility Reference Period", minval = 10, maxval = 50, group = "Exit Strategy (F-4)")

// --- R-1 & R-2: RISK MANAGEMENT SETTINGS ---
unitRiskPercent = input.float(1.0, "Risk Per Unit %", minval = 0.1, maxval = 2.0, step = 0.1, group = "Risk Management (R-1, R-2)")
maxTradeRiskPercent = input.float(4.0, "Max Total Trade Risk %", minval = 1.0, maxval = 8.0, step = 0.1, group = "Risk Management (R-1, R-2)")
atrLength = input.int(14, "ATR Length", minval = 5, maxval = 50, group = "Risk Management (R-1, R-2)")
stopLossMultiplier = input.float(5.0, "Initial Stop Loss x ATR", minval = 0.5, maxval = 10.0, step = 0.1, group = "Risk Management (R-1, R-2)")
correlateAdditionalUnits = input.bool(true, "Correlate Additional Units", group = "Risk Management (R-1, R-2)")
correlateUnit1TrailSL = input.bool(true, "Correlate Unit 1 Trail SL", group = "Risk Management (R-1, R-2)")

// --- R-4: PYRAMIDING ENGINE SETTINGS ---
enablePyramiding = input.bool(true, "Enable Unit Pyramiding", group = "Pyramiding Engine (R-4)")
maxPyramidEntries = input.int(3, "Max Additional Units (Total: 4)", minval = 1, maxval = 4, group = "Pyramiding Engine (R-4)")
pyramidSpacingATR = input.float(1.0, "Unit Spacing (ATR multiplier)", minval = 0.5, maxval = 2.0, step = 0.5, group = "Pyramiding Engine (R-4)")
trailSLOnPyramiding = input.bool(true, "Trail SL on Unit Additions", group = "Pyramiding Engine (R-4)")

// --- UI: DISPLAY SETTINGS ---
showTrendSma = input.bool(true, "Show 200 SMA", group = "Display Settings")
showStopLevels = input.bool(true, "Show Stop Loss Levels", group = "Display Settings")
showEntryArrows = input.bool(true, "Show Entry Arrows", group = "Display Settings")
showExitArrows = input.bool(true, "Show Exit Arrows", group = "Display Settings")
showTierLabels = input.bool(true, "Show Tier-Function Labels", group = "Display Settings")
arrowSize = input.string("Small", "Arrow Size", options = ["Small", "Normal", "Large"], group = "Display Settings")
showProfitZone = input.bool(true, "Show Profit Zone", group = "Display Settings")
showRiskZone = input.bool(true, "Show Risk Zone", group = "Display Settings")
showStopLossLine = input.bool(true, "Show Stop Loss Line", group = "Display Settings")
zoneTransparency = input.int(85, "Zone Transparency", minval = 80, maxval = 95, group = "Display Settings")

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  C O R E   I N D I C A T O R S                             |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Basic indicators
atr = ta.atr(atrLength)
trendSma = ta.sma(close, trendSmaLength)

// Trend filter
isTrendBullish = not trendFilterEnabled or close > trendSma

// Rolling Donchian channels (Jerry Parker style)
donchianHigh = ta.highest(high, donchianPeriod)
donchianLow = ta.lowest(low, donchianPeriod)

// Historical data sufficiency check
maxLookbackRequired = math.max(trendSmaLength, atrLength, donchianPeriod, volatilityLookback)
historicalDataSufficient = bar_index >= maxLookbackRequired

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                E N T R Y   T R I G G E R S                                 |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Secondary Entry Triggers (either can fire)
breakoutTrigger = enableBreakoutEntry and close > (donchianHigh[1] + atr * breakoutBufferATR)
dipRecoveryTrigger = enableDipBuyEntry and close > (donchianLow[1] + atr * dipRecoveryBufferATR)

// Combined entry condition: PRIMARY filter AND (any SECONDARY trigger)
entryCondition = isTrendBullish and (breakoutTrigger or dipRecoveryTrigger)



// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    R I S K   M A N A G E M E N T                             |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Position sizing calculation
unitRiskAmountDollars = strategy.equity * (unitRiskPercent / 100.0)

// Dynamic volatility adjustment for trailing stops
avgAtr = ta.sma(atr, volatilityLookback)
volatilityAdjustment = enableDynamicTrail and not na(avgAtr) and avgAtr > 0 and not na(atr) and atr > 0 ? 
                      (atr / avgAtr > 1.2 ? 1.3 : atr / avgAtr < 0.8 ? 0.7 : 1.0) : 1.0

// Adjusted trail multiplier with dynamic volatility
adjustedAtrTrailMultiplier = atrTrailMultiplier * volatilityAdjustment

// @function Calculate position size based on ATR risk
calculateUnitSize(entryPrice, stopLossPrice) =>
    if na(entryPrice) or na(stopLossPrice) or entryPrice <= 0 or stopLossPrice <= 0 or 
       unitRiskAmountDollars <= 0 or strategy.equity <= 0
        0.0
    else
        riskPerShare = math.abs(entryPrice - stopLossPrice)
        if riskPerShare <= 0
            0.0
        else
            unitValue = unitRiskAmountDollars / riskPerShare
            maxUnitValue = strategy.equity * 0.95 // Max 95% of equity
            validUnitValue = math.min(unitValue, maxUnitValue)
            math.floor(validUnitValue) // Round down to whole units

// @function Calculate ATR-based stop loss
calculateInitialStopLoss(entryPrice) =>
    if na(entryPrice) or entryPrice <= 0 or na(atr) or atr <= 0
        na
    else
        // Simple ATR stop loss
        atrStopPrice = entryPrice - (atr * stopLossMultiplier)
        
        // Final safety validation - ensure stop is below entry price
        math.min(atrStopPrice, entryPrice * 0.95) // Never closer than 5%

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    E X I T   S T R A T E G Y                                 |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Exit tracking variables
var float currentStopPrice = na
var float atrTrailStop = na
var float atrTrailHigh = na
var bool trailStartActivated = false
var float profitActivationLevel = na
var float initialStopPrice = na

// Update exit system (PRESERVED ORIGINAL LOGIC)
if strategy.position_size > 0 and not na(atr)
    entryPrice = strategy.position_avg_price
    currentProfit = close - entryPrice
    profitInATR = atr > 0 ? currentProfit / atr : 0.0
    
    // Initialize initial stop price tracking
    if na(initialStopPrice) and not na(currentStopPrice)
        initialStopPrice := currentStopPrice
    
    if exitMode == "ATR Trail"
        // Calculate profit activation level for trailing (only set once)
        if na(profitActivationLevel)
            profitActivationLevel := entryPrice + (atr * trailStartProfitMultiplier)
        
        // Check if trailing should start
        if not trailStartActivated
            // Start trailing when profit threshold is reached
            if close >= profitActivationLevel
                trailStartActivated := true
                atrTrailHigh := close
        
        // Update trailing stop if activated
        if trailStartActivated
            // Update trail high on new highs
            if high > atrTrailHigh
                atrTrailHigh := high
            
            // Calculate new trailing stop using dynamic adjustment
            newTrailStop = atrTrailHigh - (atr * adjustedAtrTrailMultiplier)
            
            // Ensure trailing stop never moves down
            if na(atrTrailStop)
                atrTrailStop := newTrailStop
            else
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
            
            // Apply Unit 1 trail correlation if enabled
            if correlateUnit1TrailSL
                atrTrailStop := math.max(atrTrailStop, currentStopPrice)
            
            currentStopPrice := math.max(currentStopPrice, atrTrailStop)
else
    // Reset when no position
    currentStopPrice := na
    atrTrailStop := na
    atrTrailHigh := na
    trailStartActivated := false
    profitActivationLevel := na
    initialStopPrice := na

// Exit conditions
stopLossHit = strategy.position_size > 0 and not na(currentStopPrice) and low <= currentStopPrice
trendFilterFail = strategy.position_size > 0 and not isTrendBullish

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                             T R A D E   E X E C U T I O N                                   |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Pyramiding tracking (Tier System)
var int currentTierCount = 0
var float lastTierPrice = na

// Entry/Exit type tracking for UI labels
var string lastEntryType = na
var string lastExitType = na
var int lastEntryTier = na
var int lastExitTier = na

// Zone tracking for trade duration (scalable across timeframes)
var box profitZone = na
var box riskZone = na
var line stopLossLine = na
var int tradeStartBar = na
var float tradeEntryPrice = na

// Entry execution
if strategy.position_size == 0 and entryCondition and not na(atr) and atr > 0 and historicalDataSufficient
    initialStop = calculateInitialStopLoss(close)
    if not na(initialStop) and initialStop < close
        unitSize = calculateUnitSize(close, initialStop)
        if unitSize > 0
            // Determine entry type for UI labeling
            entryType = breakoutTrigger ? "F2" : dipRecoveryTrigger ? "F3" : "F2"
            
            strategy.entry("Tier 1 Long", strategy.long, qty=unitSize)
            currentStopPrice := initialStop
            currentTierCount := 0
            lastTierPrice := na
            
            // Track entry for UI labels
            lastEntryType := entryType
            lastEntryTier := 1
            
            // Initialize trade tracking for zones
            tradeStartBar := bar_index
            tradeEntryPrice := close

// Pyramiding execution (TIER SYSTEM LOGIC)
if enablePyramiding and strategy.position_size > 0 and currentTierCount < maxPyramidEntries and not na(atr) and atr > 0
    // Calculate profit in ATR terms
    entryPrice = strategy.position_avg_price
    profitInN = atr > 0 ? (close - entryPrice) / atr : 0.0
    
    // ATR threshold for next tier
    nextTierThreshold = (currentTierCount + 1) * pyramidSpacingATR
    
    // Check conditions for adding tiers
    atrThresholdMet = profitInN >= nextTierThreshold
    priceDistanceOk = na(lastTierPrice) or math.abs(close - lastTierPrice) >= (atr * pyramidSpacingATR)
    pyramidCondition = atrThresholdMet and priceDistanceOk
    
    // Risk check: ensure we don't exceed max trade risk
    currentTradeRisk = strategy.equity > 0 ? 
                      (strategy.position_size * math.abs(strategy.position_avg_price - currentStopPrice) / strategy.equity * 100) : 
                      100.0  // If equity is 0 or negative, assume max risk
    wouldExceedMaxRisk = currentTradeRisk + unitRiskPercent > maxTradeRiskPercent
    
    if pyramidCondition and not wouldExceedMaxRisk
        // Calculate stop for additional tier
        tierStopPrice = calculateInitialStopLoss(close)
        
        // Apply correlation logic for additional tiers
        if correlateAdditionalUnits
            tierStopPrice := math.max(tierStopPrice, currentStopPrice)
        
        tierSize = calculateUnitSize(close, tierStopPrice)
        
        if tierSize > 0
            // Determine entry type for additional tier
            entryType = breakoutTrigger ? "F2" : dipRecoveryTrigger ? "F3" : "F2"
            tierNumber = currentTierCount + 2
            tierId = "Tier " + str.tostring(tierNumber) + " Long"
            
            strategy.entry(tierId, strategy.long, qty=tierSize)
            currentTierCount := currentTierCount + 1
            lastTierPrice := close
            
            // Track entry for UI labels
            lastEntryType := entryType
            lastEntryTier := tierNumber
            
            // Update stop to protect new tier with correlation
            if correlateAdditionalUnits
                currentStopPrice := math.max(currentStopPrice, tierStopPrice)
            else
                currentStopPrice := tierStopPrice
            
            // Update trailing stop logic for additional tiers if enabled
            if trailSLOnPyramiding and trailStartActivated
                newTrailStop = atrTrailHigh - (atr * adjustedAtrTrailMultiplier)
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
                currentStopPrice := math.max(currentStopPrice, atrTrailStop)

// Exit execution (WHEN TRAILING STOP IS HIT, ALL POSITIONS EXIT)
if stopLossHit
    // Track exit type for UI labeling
    lastExitType := "F4"  // Trailing stop exit
    lastExitTier := currentTierCount + 1  // Current total tiers
    strategy.close_all(comment="Trailing Stop Hit")
else if trendFilterFail
    // Track exit type for UI labeling
    lastExitType := "F1"  // Trend filter exit
    lastExitTier := currentTierCount + 1  // Current total tiers
    strategy.close_all(comment="Trend Filter Fail")

// Reset tracking on position close
if strategy.position_size == 0
    currentTierCount := 0
    lastTierPrice := na

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                        P R O F I T / R I S K   Z O N E   M A N A G E M E N T               |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// Zone colors with user-configurable transparency
PROFIT_ZONE_COLOR = color.new(color.green, zoneTransparency)
RISK_ZONE_COLOR = color.new(color.red, zoneTransparency)
DARK_RED_LINE = color.new(color.red, 0)

// Zone management (trade duration based)
if strategy.position_size > 0 and not na(currentStopPrice) and not na(tradeStartBar)
    // Calculate zone boundaries
    currentPrice = close
    upperBound = high * 1.05  // Dynamic upper bound (5% above current high)
    lowerBound = currentStopPrice
    
    // Profit Zone: Current price to upper chart area
    if showProfitZone
        // Delete existing profit zone
        if not na(profitZone)
            box.delete(profitZone)
        
        // Create new profit zone from trade start to current bar
        profitZone := box.new(
            left=tradeStartBar, 
            top=upperBound, 
            right=bar_index, 
            bottom=currentPrice,
            bgcolor=PROFIT_ZONE_COLOR, 
            border_color=color.new(color.green, 50),
            border_width=1,
            extend=extend.right
        )
    
    // Risk Zone: Current price to stop loss
    if showRiskZone and currentPrice > lowerBound
        // Delete existing risk zone
        if not na(riskZone)
            box.delete(riskZone)
        
        // Create new risk zone from trade start to current bar
        riskZone := box.new(
            left=tradeStartBar, 
            top=currentPrice, 
            right=bar_index, 
            bottom=lowerBound,
            bgcolor=RISK_ZONE_COLOR, 
            border_color=color.new(color.red, 50),
            border_width=1,
            extend=extend.right
        )
    
    // Stop Loss Line: Continuous line across trade duration
    if showStopLossLine
        // Delete existing stop loss line
        if not na(stopLossLine)
            line.delete(stopLossLine)
        
        // Create new stop loss line
        stopLossLine := line.new(
            x1=tradeStartBar, 
            y1=currentStopPrice, 
            x2=bar_index, 
            y2=currentStopPrice,
            color=DARK_RED_LINE, 
            width=2,
            extend=extend.right,
            style=line.style_solid
        )

else
    // No position - clean up all zones
    if not na(profitZone)
        box.delete(profitZone)
        profitZone := na
    if not na(riskZone)
        box.delete(riskZone)
        riskZone := na
    if not na(stopLossLine)
        line.delete(stopLossLine)
        stopLossLine := na
    
    // Reset zone tracking
    tradeStartBar := na
    tradeEntryPrice := na

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                V I S U A L   I N T E R F A C E                             |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// UI Colors (per UI.mdc specification)
BRIGHT_BLUE = color.new(#0080FF, 0)
BRIGHT_ORANGE = color.new(#FF8000, 0)
PROFESSIONAL_BLUE = color.new(color.blue, 20)
SUBTLE_GREEN = color.new(color.green, 97)

// Arrow size configuration
arrowSizeValue = arrowSize == "Small" ? size.small : arrowSize == "Normal" ? size.normal : size.large

// Essential plots
plot(showTrendSma ? trendSma : na, "200 SMA", color=PROFESSIONAL_BLUE, linewidth=1)

// Entry detection and labeling
entryDetected = strategy.position_size > 0 and strategy.position_size[1] == 0
exitDetected = strategy.position_size == 0 and strategy.position_size[1] > 0

// Generate entry labels
entryLabel = showTierLabels and not na(lastEntryType) and not na(lastEntryTier) ? 
            "T" + str.tostring(lastEntryTier) + "-" + lastEntryType : ""

// Generate exit labels  
exitLabel = showTierLabels and not na(lastExitType) and not na(lastExitTier) ?
           "T" + str.tostring(lastExitTier) + "-" + lastExitType : ""

// Entry arrows (bright blue, upward)
plotshape(
    showEntryArrows and entryDetected, 
    title="Entry Arrow",
    style=shape.arrowup, 
    location=location.belowbar, 
    color=BRIGHT_BLUE, 
    size=arrowSizeValue,
    text=entryLabel
)

// Exit arrows (bright orange, downward) 
plotshape(
    showExitArrows and exitDetected,
    title="Exit Arrow", 
    style=shape.arrowdown,
    location=location.abovebar,
    color=BRIGHT_ORANGE,
    size=arrowSizeValue,
    text=exitLabel
)

// Position status background (very subtle)
positionColor = strategy.position_size > 0 ? SUBTLE_GREEN : na
bgcolor(showStopLevels ? positionColor : na, title="Position Status")