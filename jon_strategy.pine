//@version=6
strategy("JON - Robust Trading Strategy",
     shorttitle="JON",
     overlay=true,
     pyramiding=3,
     // FIX: Changed default_qty_type to 'fixed' to allow our manual position sizing to work.
     // The original 'percent_of_equity' setting overrode all our custom risk logic.
     default_qty_type=strategy.fixed,
     initial_capital=100000,
     currency=currency.USD,
     commission_type=strategy.commission.percent,
     commission_value=0.1)

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                S T R A T E G Y   I N F O R M A T I O N                       |
// ——————————————————————————————————————————————————————————————————————————————————————————————
// JON Strategy - A robust, multi-asset trading system designed for superior risk-adjusted returns
//
// Core Philosophy:
// - Automate Everything: Full algorithmic execution without manual intervention
// - Robustness over Optimization: Works across multiple asset classes and market conditions
// - Sidestep Bear Markets: Preserves capital during major downturns
// - Low-Frequency Investing: High-quality signals, typically <1 trade per month per asset
//
// Primary Assets: BTCUSD, NDX/QQQ, XAUUSD
// Strategy Type: Trend-following with dual entry system and configurable exits
// Risk Management: ATR-based position sizing with hard stops

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  I N P U T   P A R A M E T E R S                           |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- F-1: TREND FILTER SETTINGS ---
trendFilterEnabled = input.bool(true, "Enable 200 SMA Trend Filter", group = "Trend Filter (F-1)")
trendSmaLength = input.int(200, "Trend SMA Length", minval = 50, maxval = 500, group = "Trend Filter (F-1)")
useReferenceAsset = input.bool(false, "Use Reference Asset Filter", group = "Trend Filter (F-1)")
referenceSymbol = input.symbol("CRYPTOCAP:TOTAL", "Reference Asset Symbol", group = "Trend Filter (F-1)")

// --- F-2: BREAKOUT ENTRY SETTINGS ---
enableBreakoutEntry = input.bool(true, "Enable Breakout Entry", group = "Breakout Entry (F-2)")
breakoutLookback = input.int(250, "Breakout Lookback Period (bars)", minval = 5, maxval = 500, group = "Breakout Entry (F-2)")
breakoutMinAge = input.int(20, "Minimum High Age (bars)", minval = 1, maxval = 100, group = "Breakout Entry (F-2)")
breakoutMaxAge = input.int(200, "Maximum High Age (bars)", minval = 5, maxval = 500, group = "Breakout Entry (F-2)")

// --- F-3: DIP BUY ENTRY SETTINGS ---
enableDipBuyEntry = input.bool(true, "Enable Dip Buy Entry", group = "Dip Buy Entry (F-3)")
dipBuyLookback = input.int(60, "Dip Buy Lookback Period (bars)", minval = 5, maxval = 200, group = "Dip Buy Entry (F-3)")
dipRecoveryThreshold = input.float(1.0, "Recovery Threshold %", minval = 0.1, maxval = 5.0, step = 0.1, group = "Dip Buy Entry (F-3)")

// --- F-4: EXIT STRATEGY SETTINGS ---
exitMode = input.string("ATR Trail", "Exit Strategy Mode", options = ["ATR Trail", "Aggressive Profit Take"], group = "Exit Strategy (F-4)")
atrTrailMultiplier = input.float(3.0, "ATR Trail Multiplier", minval = 0.5, maxval = 10.0, step = 0.1, group = "Exit Strategy (F-4)")
aggressiveProfitTarget = input.float(10.0, "Aggressive Profit Target %", minval = 1.0, maxval = 50.0, step = 0.5, group = "Exit Strategy (F-4)")

// --- F-5: OPPORTUNISTIC EXIT SETTINGS ---
enableOpportunisticExit = input.bool(true, "Enable Opportunistic Exit", group = "Opportunistic Exit (F-5)")
failedBreakoutBars = input.int(10, "Failed Breakout Timeout (bars)", minval = 3, maxval = 50, group = "Opportunistic Exit (F-5)")

// --- R-1 & R-2: RISK MANAGEMENT SETTINGS ---
riskPercent = input.float(1.0, "Risk Per Trade %", minval = 0.1, maxval = 10.0, step = 0.1, group = "Risk Management (R-1, R-2)")
atrLength = input.int(14, "ATR Length", minval = 5, maxval = 50, group = "Risk Management (R-1, R-2)")
stopLossMultiplier = input.float(2.5, "Stop Loss ATR Multiplier", minval = 0.5, maxval = 10.0, step = 0.1, group = "Risk Management (R-1, R-2)")

// --- UI-1 & UI-2: DISPLAY SETTINGS ---
showTrendSma = input.bool(true, "Show 200 SMA", group = "Display Settings (UI-1, UI-2)")
showStopLevels = input.bool(true, "Show Stop Loss Levels", group = "Display Settings (UI-1, UI-2)")
showTradeLabels = input.bool(true, "Show Trade Entry/Exit Labels", group = "Display Settings (UI-1, UI-2)")

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    C O R E   I N D I C A T O R S                           |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- PRIMARY ASSET INDICATORS ---
trendSma = ta.sma(close, trendSmaLength)
isTrendBullish = not trendFilterEnabled or close > trendSma
atr = ta.atr(atrLength)
isDataValid = not na(close) and not na(atr) and atr > 0 and strategy.equity > 0

// --- REFERENCE ASSET INDICATORS ---
referenceClose = useReferenceAsset ? request.security(referenceSymbol, timeframe.period, close) : na
// Fix: Extract ta.sma call from conditional scope for consistency
referenceSmaValue = useReferenceAsset and not na(referenceClose) ? ta.sma(referenceClose, trendSmaLength) : na
referenceSma = referenceSmaValue
isReferenceBullish = not useReferenceAsset or (not na(referenceSma) and referenceClose > referenceSma)

// --- FINAL TREND FILTER VALIDATION ---
isTrendFilterPassed = isTrendBullish and isReferenceBullish

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                  S I G N A L   D E T E C T I O N                             |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- F-2: BREAKOUT ENTRY ---
// FIX: This is a more robust way to find a high that meets the age criteria.
var float validRecentHigh = na
var int validRecentHighAge = na
if (enableBreakoutEntry)
    for i = breakoutMinAge to breakoutLookback
        if (i > breakoutMaxAge)
            break
        currentHigh = high[i]
        if (na(validRecentHigh) or currentHigh > validRecentHigh)
            validRecentHigh := currentHigh
            validRecentHighAge := i
isRecentHighValid = not na(validRecentHigh)
// Fix: Extract ta.crossover call from conditional scope for consistency
crossoverSignal = ta.crossover(close, validRecentHigh)
breakoutEntryCondition = enableBreakoutEntry and isTrendFilterPassed and isDataValid and isRecentHighValid and crossoverSignal

// --- F-3: DIP BUY ENTRY ---
recentLow = ta.lowest(low, dipBuyLookback)
isDipRecovering = close > recentLow * (1 + dipRecoveryThreshold / 100)
dipBuyEntryCondition = enableDipBuyEntry and isTrendFilterPassed and isDataValid and isDipRecovering

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    R I S K   M A N A G E M E N T                             |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- R-1: POSITION SIZING ---
riskAmountDollars = strategy.equity * (riskPercent / 100.0)

// Fixed function definition for v6 - removed 'method' keyword
calculatePositionSize(entryPrice, stopLossPrice) =>
    if (na(entryPrice) or na(stopLossPrice) or riskAmountDollars <= 0)
        0.0
    else
        riskPerShare = math.abs(entryPrice - stopLossPrice)
        riskPerShare > 0 ? riskAmountDollars / riskPerShare : 0.0

// --- R-2: STOP LOSS ---
// Fixed function definition for v6 - removed 'method' keyword
calculateInitialStopLoss(entryPrice, entryType) =>
    stopPrice = entryPrice - (atr * stopLossMultiplier)
    // Fix: Extract ta.lowest calls from conditional scope for consistency
    recentSwingLow = ta.lowest(low, 10) * 0.995
    recentDipLow = recentLow * 0.99
    if entryType == "BREAKOUT"
        // For breakouts, ensure stop is below a recent swing low
        stopPrice := math.min(stopPrice, recentSwingLow)
    else if entryType == "DIP_BUY"
        // For dip buys, ensure stop is below the identified recent low
        stopPrice := math.min(stopPrice, recentDipLow)
    stopPrice

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                    E X I T   S T R A T E G Y                                 |
// ——————————————————————————————————————————————————————————————————————————————————————————————

var float currentStopPrice = na
var float atrTrailStop = na
var float atrTrailHigh = na
var float aggressiveProfitPrice = na

// --- F-4: EXIT SYSTEM UPDATE LOGIC ---
if strategy.position_size > 0
    if exitMode == "ATR Trail"
        // Initialize trail on first bar of trade or update on new high
        if na(atrTrailHigh) or high > atrTrailHigh
            atrTrailHigh := high
            atrTrailStop := atrTrailHigh - (atr * atrTrailMultiplier)
        // Ensure trailing stop never moves down
        atrTrailStop := na(atrTrailStop[1]) ? atrTrailStop : math.max(atrTrailStop, atrTrailStop[1])
        currentStopPrice := math.max(currentStopPrice, atrTrailStop)
    else if exitMode == "Aggressive Profit Take"
        if na(aggressiveProfitPrice)
            aggressiveProfitPrice := strategy.position_avg_price * (1 + aggressiveProfitTarget / 100)
else // No position open, reset all exit variables
    currentStopPrice := na
    atrTrailStop := na
    atrTrailHigh := na
    aggressiveProfitPrice := na

// --- EXIT CONDITIONS ---
stopLossHit = strategy.position_size > 0 and not na(currentStopPrice) and low <= currentStopPrice
profitTargetHit = strategy.position_size > 0 and exitMode == "Aggressive Profit Take" and not na(aggressiveProfitPrice) and high >= aggressiveProfitPrice

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                             T R A D E   E X E C U T I O N   E N G I N E                      |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- F-5: OPPORTUNISTIC EXIT TRACKING ---
var float breakoutEntryPrice = na
var int breakoutEntryBar = na
var bool isBreakoutPosition = false

// --- ENTRY EXECUTION ---
if (strategy.position_size == 0 and isDataValid)
    float initialStop = na
    float positionSize = na
    string entryId = ""

    if breakoutEntryCondition
        initialStop := calculateInitialStopLoss(close, "BREAKOUT")
        positionSize := calculatePositionSize(close, initialStop)
        entryId := "Breakout Long"
        // Track breakout entry for F-5 opportunistic exit
        breakoutEntryPrice := close
        breakoutEntryBar := bar_index
        isBreakoutPosition := true
    else if dipBuyEntryCondition
        initialStop := calculateInitialStopLoss(close, "DIP_BUY")
        positionSize := calculatePositionSize(close, initialStop)
        entryId := "Dip Buy Long"
        // Dip buy entries don't use opportunistic exit
        isBreakoutPosition := false

    if positionSize > 0
        strategy.entry(entryId, strategy.long, qty=positionSize)
        currentStopPrice := initialStop // Set the initial hard stop

// --- F-5: OPPORTUNISTIC EXIT CONDITIONS ---
failedBreakoutExit = false
if (enableOpportunisticExit and strategy.position_size > 0 and isBreakoutPosition and not na(breakoutEntryPrice) and not na(breakoutEntryBar))
    barsSinceEntry = bar_index - breakoutEntryBar
    
    // Fix: Extract ta.highest call from conditional scope for consistency
    highSinceEntry = ta.highest(high, barsSinceEntry)
    
    // F-5: Exit if breakout fails to make new high within timeout
    if barsSinceEntry >= failedBreakoutBars
        if highSinceEntry <= breakoutEntryPrice * 1.005 // No meaningful follow-through (0.5% threshold)
            failedBreakoutExit := true
    
    // F-5: Exit if close falls 2% below entry (significant weakness)
    if close < breakoutEntryPrice * 0.98
        failedBreakoutExit := true

// --- EXIT EXECUTION ---
if strategy.position_size > 0
    if failedBreakoutExit
        strategy.close_all(comment="Failed Breakout")
    else if stopLossHit
        strategy.close_all(comment="Stop Loss / Trail Hit")
    else if profitTargetHit
        strategy.close_all(comment="Profit Target Hit")
    else if not isTrendFilterPassed
        strategy.close_all(comment="Trend Filter Fail (Bear Market)")

// --- RESET TRACKING ON POSITION CLOSE ---
if strategy.position_size == 0
    breakoutEntryPrice := na
    breakoutEntryBar := na
    isBreakoutPosition := false

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                                V I S U A L   I N T E R F A C E (UI)                        |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- INDICATORS ---
plot(showTrendSma ? trendSma : na, "200 SMA", color = isTrendBullish ? color.new(color.green, 20) : color.new(color.red, 20), linewidth=2)

// --- STOP LEVELS ---
// FIX: Simplified plotting logic to use the single, reliable currentStopPrice variable
plot(showStopLevels and strategy.position_size > 0 ? currentStopPrice : na, "Stop Loss Level", color = color.new(color.red, 0), style = plot.style_linebr, linewidth = 2)
plot(showStopLevels and not na(aggressiveProfitPrice) ? aggressiveProfitPrice : na, "Profit Target", color = color.new(color.lime, 40), style = plot.style_linebr, linewidth = 2)

// --- ENTRY/EXIT LABELS ---
// Fixed: Moved plotshape calls to global scope with proper conditional logic
// Track entry and exit events with proper variable scope
var bool showBreakoutEntry = false
var bool showDipBuyEntry = false
var bool showExit = false
var bool wasFailedBreakout = false
var string entryType = ""

// Update label flags based on position changes
if strategy.position_size > 0 and strategy.position_size[1] == 0
    // Position just opened - determine entry type
    entryType := strategy.opentrades.entry_id(strategy.opentrades - 1)
    if str.contains(entryType, "Breakout")
        showBreakoutEntry := true
        showDipBuyEntry := false
    else if str.contains(entryType, "Dip Buy")
        showBreakoutEntry := false
        showDipBuyEntry := true
    showExit := false
else if strategy.position_size == 0 and strategy.position_size[1] > 0
    // Position just closed
    showBreakoutEntry := false
    showDipBuyEntry := false
    showExit := true
    wasFailedBreakout := failedBreakoutExit[1]
else
    // No position change
    showBreakoutEntry := false
    showDipBuyEntry := false
    showExit := false

// Plot shapes in global scope with conditional display
plotshape(showBreakoutEntry, title="Breakout Entry", location=location.belowbar, color=color.new(color.blue, 0), style=shape.labelup, size=size.small, text="BREAKOUT\nENTRY", textcolor=color.white)
plotshape(showDipBuyEntry, title="Dip Buy Entry", location=location.belowbar, color=color.new(color.green, 0), style=shape.labelup, size=size.small, text="DIP BUY\nENTRY", textcolor=color.white)
plotshape(showExit, title="Exit", location=location.abovebar, color=wasFailedBreakout ? color.new(color.orange, 0) : color.new(color.purple, 0), style=shape.labeldown, size=size.small, text=wasFailedBreakout ? "FAILED\nBREAKOUT" : "EXIT", textcolor=color.white)

// ——————————————————————————————————————————————————————————————————————————————————————————————
// |                        U I - 2 :   P E R F O R M A N C E   T A B L E                        |
// ——————————————————————————————————————————————————————————————————————————————————————————————

// --- BUY & HOLD BENCHMARK CALCULATION ---
var float buyHoldEntry = na
var float buyHoldShares = na

// Initialize buy and hold on first bar
if barstate.isfirst
    buyHoldEntry := close
    buyHoldShares := strategy.initial_capital / close

// Calculate current buy & hold equity
buyHoldEquity = buyHoldShares * close
buyHoldReturn = (buyHoldEquity - strategy.initial_capital) / strategy.initial_capital * 100
strategyReturn = (strategy.equity - strategy.initial_capital) / strategy.initial_capital * 100
excessReturn = strategyReturn - buyHoldReturn

// Current signal status
currentSignal = breakoutEntryCondition ? "BREAKOUT" : dipBuyEntryCondition ? "DIP BUY" : "WAIT"

// --- PERFORMANCE TABLE (UI-2) ---
if barstate.islast
    var table perfTable = table.new(position.top_right, 2, 10, bgcolor=color.new(color.white, 80), border_width=1)
    
    // Headers
    table.cell(perfTable, 0, 0, "Metric", text_color=color.black, bgcolor=color.new(color.gray, 70))
    table.cell(perfTable, 1, 0, "Value", text_color=color.black, bgcolor=color.new(color.gray, 70))
    
    // Strategy Return
    table.cell(perfTable, 0, 1, "Strategy Return", text_color=color.black)
    table.cell(perfTable, 1, 1, str.tostring(strategyReturn, "#.##") + "%", 
               text_color=strategyReturn > 0 ? color.green : color.red)
    
    // Buy & Hold Return
    table.cell(perfTable, 0, 2, "Buy & Hold Return", text_color=color.black)
    table.cell(perfTable, 1, 2, str.tostring(buyHoldReturn, "#.##") + "%", 
               text_color=buyHoldReturn > 0 ? color.green : color.red)
    
    // Excess Return
    table.cell(perfTable, 0, 3, "Excess Return", text_color=color.black)
    table.cell(perfTable, 1, 3, str.tostring(excessReturn, "#.##") + "%", 
               text_color=excessReturn > 0 ? color.green : color.red)
    
    // Max Drawdown
    table.cell(perfTable, 0, 4, "Max Drawdown", text_color=color.black)
    table.cell(perfTable, 1, 4, str.tostring(strategy.max_drawdown, "#.##") + "%", text_color=color.red)
    
    // Net Profit
    table.cell(perfTable, 0, 5, "Net Profit", text_color=color.black)
    table.cell(perfTable, 1, 5, "$" + str.tostring(strategy.netprofit, "#,###"), 
               text_color=strategy.netprofit > 0 ? color.green : color.red)
    
    // Profit Factor
    table.cell(perfTable, 0, 6, "Profit Factor", text_color=color.black)
    profitFactor = strategy.grossloss == 0 ? na : strategy.grossprofit / math.abs(strategy.grossloss)
    table.cell(perfTable, 1, 6, na(profitFactor) ? "N/A" : str.tostring(profitFactor, "#.##"), text_color=color.blue)
    
    // Total Trades
    table.cell(perfTable, 0, 7, "Total Trades", text_color=color.black)
    table.cell(perfTable, 1, 7, str.tostring(strategy.closedtrades), text_color=color.blue)
    
    // Win Rate
    table.cell(perfTable, 0, 8, "Win Rate", text_color=color.black)
    winRate = strategy.closedtrades == 0 ? na : strategy.wintrades / strategy.closedtrades * 100
    table.cell(perfTable, 1, 8, na(winRate) ? "N/A" : str.tostring(winRate, "#.##") + "%", 
               text_color=na(winRate) ? color.gray : (winRate > 50 ? color.green : color.red))
    
    // Current Signal
    table.cell(perfTable, 0, 9, "Current Signal", text_color=color.black)
    signalColor = currentSignal == "WAIT" ? color.gray : color.blue
    table.cell(perfTable, 1, 9, currentSignal, text_color=signalColor)

// --- BACKGROUND COLOR ---
bgcolor(isTrendFilterPassed ? color.new(color.blue, 90) : color.new(color.gray, 90))