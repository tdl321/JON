// Â© 2025 JON Systems
//@version=6
strategy("JON",
     shorttitle="JON",
     overlay=true,
     pyramiding=4,
     default_qty_type=strategy.fixed,
     initial_capital=100000,
     currency=currency.USD,
     commission_type=strategy.commission.percent,
     commission_value=0.1)

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                S T R A T E G Y   I N F O R M A T I O N                       |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// JON MTP BETA v4 Strategy - Universal Higher Timeframe Trend Following System
//
// STRATEGY PHILOSOPHY:
// This strategy prioritizes ROBUSTNESS above all else. 
//
// CORE REQUIREMENTS:
// - REACTIVE ENTRIES: Accept many small losses to maximize chances of catching strong trends
// - EXIT-FOCUSED DESIGN: Entry timing is secondary; exit strategy is the critical component
// - NO TAKE PROFIT: Pure trend following with asymmetric profit targeting
// - ATR-BASED TRAILING STOPS: Let winners run until trend definitively reverses
// - WIDE ASSET COVERAGE: Cast net broadly to increase probability of capturing major bull runs
// - STATISTICS DRIVEN: Relies on probabilities and large sample sizes, not individual trade outcomes
//
// PERFORMANCE FRAMEWORK:
// - Frequent trades with small individual risks
// - Portfolio carried by occasional massive winners (asymmetric returns)
// - Drawdown tolerance HIGH - focused purely on annualized performance
// - Simple core logic with anti-whipsaw flexibility built in
//
// Key Success Factors:
// - Much longer holding periods capture major trends fully
// - Wider stops avoid noise-based exits in volatile markets
// - Reference asset provides macro timing improvement
// - Age validation prevents recency bias and noise
//
// UNIVERSAL COMPATIBILITY:
// - ALL assets: Crypto, indices, futures, metals, forex

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                  I N P U T   P A R A M E T E R S                           |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”



// --- F-1: TREND FILTER SETTINGS ---
trendFilterEnabled = input.bool(true, "Enable 100 EMA Trend Filter", group = "Trend Filter (F-1)")
trendEmaLength = input.int(100, "Trend EMA Length", minval = 50, maxval = 500, group = "Trend Filter (F-1)")
trendAtrBuffer = input.float(1.5, "Trend ATR Buffer", minval = 0.0, maxval = 3.0, step = 0.1, group = "Trend Filter (F-1)", tooltip = "Allow entries when price is within X ATR below EMA (0 = strict, 0.5 = moderate, 1.5 = aggressive)")
useReferenceAsset = input.bool(false, "Use Reference Asset Filter", group = "Trend Filter (F-1)")
referenceSymbol = input.symbol("CRYPTOCAP:TOTAL", "Reference Asset Symbol", group = "Trend Filter (F-1)")

// --- F-2: BREAKOUT ENTRY SETTINGS (Simplified System) ---
enableBreakoutEntry = input.bool(true, "Enable Breakout Entry", group = "Breakout Entry (F-2)")
breakoutLookback = input.int(50, "Breakout Lookback Period", minval = 10, maxval = 200, group = "Breakout Entry (F-2)", tooltip = "Look for highs over this many bars back")
breakoutCrossWithinDays = input.int(20, "Cross Above Within (days)", minval = 1, maxval = 60, group = "Breakout Entry (F-2)", tooltip = "Must cross above high within this many days")
breakoutMinAgeDays = input.int(20, "Min Age of Crossed High (days)", minval = 1, maxval = 100, group = "Breakout Entry (F-2)", tooltip = "High must be at least this many days old")
breakoutMaxAgeDays = input.int(200, "Max Age of Crossed High (days)", minval = 5, maxval = 500, group = "Breakout Entry (F-2)", tooltip = "High must not be older than this many days")

// --- F-3: DIP BUY ENTRY SETTINGS (Simplified System) ---
enableDipBuyEntry = input.bool(true, "Enable Dip Buy Entry", group = "Dip Buy Entry (F-3)")
dipLookback = input.int(50, "Dip Lookback Period", minval = 10, maxval = 200, group = "Dip Buy Entry (F-3)", tooltip = "Look for lows over this many bars back")
dipRecoveryWithinDays = input.int(30, "Recovery Within (days)", minval = 1, maxval = 90, group = "Dip Buy Entry (F-3)", tooltip = "Must recover from low within this many days")
dipMinAgeDays = input.int(15, "Min Age of Crossed Low (days)", minval = 1, maxval = 100, group = "Dip Buy Entry (F-3)", tooltip = "Low must be at least this many days old")
dipMaxAgeDays = input.int(90, "Max Age of Crossed Low (days)", minval = 5, maxval = 200, group = "Dip Buy Entry (F-3)", tooltip = "Low must not be older than this many days")
dipTouchBuffer = input.float(0.5, "Dip Touch Buffer %", minval = 0.1, maxval = 1.0, step = 0.1, group = "Dip Buy Entry (F-3)")
dipRecoveryBufferATR = input.float(0.1, "Recovery Buffer (ATR multiplier)", minval = 0.05, maxval = 0.5, step = 0.05, group = "Dip Buy Entry (F-3)", tooltip = "Must recover this many ATR above swing low to trigger entry")

// --- F-4: EXIT STRATEGY SETTINGS (HIGH PERFORMANCE) ---
exitMode = input.string("ATR Trail", "Exit Strategy Mode", options = ["ATR Trail"], group = "Exit Strategy (F-4)")
atrTrailMultiplier = input.float(8.0, "Trailing Distance x ATR", minval = 0.5, maxval = 25.0, step = 0.5, group = "Exit Strategy (F-4)")
trailStartProfitMultiplier = input.float(5.0, "Trailing Start at Profit x ATR", minval = 1.0, maxval = 20.0, step = 0.1, group = "Exit Strategy (F-4)")
trailOnTouchHigh = input.bool(true, "Trail Start on Touch High", group = "Exit Strategy (F-4)")
enableDynamicTrail = input.bool(true, "Enable Dynamic Trail Adjustment", group = "Exit Strategy (F-4)")
volatilityLookback = input.int(14, "Volatility Reference Period", minval = 10, maxval = 50, group = "Exit Strategy (F-4)")

// --- R-1 & R-2: RISK MANAGEMENT SETTINGS ---
unitRiskPercent = input.float(2.0, "Risk Per Unit %", minval = 0.1, maxval = 10.0, step = 0.1, group = "Risk Management (R-1, R-2)")
maxTradeRiskPercent = input.float(25.0, "Max Total Trade Risk %", minval = 1.0, maxval = 50.0, step = 0.1, group = "Risk Management (R-1, R-2)")
atrLength = input.int(50, "ATR Length", minval = 5, maxval = 100, group = "Risk Management (R-1, R-2)")
stopLossMultiplier = input.float(5.0, "Initial Stop Loss x ATR", minval = 0.5, maxval = 10.0, step = 0.1, group = "Risk Management (R-1, R-2)")
correlateUnit1 = input.bool(true, "Correlate Unit 1 Entry", group = "Risk Management (R-1, R-2)")
correlateAdditionalUnits = input.bool(true, "Correlate Additional Units", group = "Risk Management (R-1, R-2)")
correlateUnit1TrailSL = input.bool(true, "Correlate Unit 1 Trail SL", group = "Risk Management (R-1, R-2)")

// --- R-4: PYRAMIDING ENGINE SETTINGS ---
enablePyramiding = input.bool(true, "Enable Unit Pyramiding", group = "Pyramiding Engine (R-4)")
maxPyramidEntries = input.int(4, "Max Additional Units (Total: 5)", minval = 1, maxval = 4, group = "Pyramiding Engine (R-4)")
pyramidSpacingATR = input.float(1.0, "Unit Spacing (ATR multiplier)", minval = 0.5, maxval = 2.0, step = 0.5, group = "Pyramiding Engine (R-4)")
trailSLOnPyramiding = input.bool(true, "Trail SL on Unit Additions", group = "Pyramiding Engine (R-4)")

// --- UI: DISPLAY SETTINGS ---
showTrendEma = input.bool(true, "Show 100 EMA", group = "Display Settings")
showStopLevels = input.bool(true, "Show Stop Loss Levels", group = "Display Settings")
showEntryArrows = input.bool(true, "Show Entry Arrows", group = "Display Settings")
showExitArrows = input.bool(true, "Show Exit Arrows", group = "Display Settings")
arrowSize = "Small"
showProfitZone = input.bool(false, "Show Profit Zone", group = "Display Settings")
showRiskZone = input.bool(false, "Show Risk Zone", group = "Display Settings")
showStopLossLine = input.bool(true, "Show Stop Loss Line", group = "Display Settings")
// showStopLossLine input removed - static stop-loss line deprecated
showHistoricalZones = input.bool(true, "Show Historical Zones", group = "Display Settings")
zoneTransparency = input.int(85, "Zone Transparency", minval = 80, maxval = 95, group = "Display Settings")
maxHistoricalZones = input.int(50, "Max Historical Zones", minval = 10, maxval = 100, group = "Display Settings")
showDebugInfo = input.bool(false, "Show Debug Info", group = "Display Settings")
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                  C O R E   I N D I C A T O R S                             |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Basic indicators with EXTENDED ATR period (KEY DIFFERENCE) - using native chart data
atr = ta.atr(atrLength)  // 100-period ATR for stability
trendEma = ta.ema(close, trendEmaLength)

// Reference asset data for correlation (KEY FEATURE) - using chart timeframe
referenceClose = useReferenceAsset ? request.security(referenceSymbol, timeframe.period, close, lookahead=barmerge.lookahead_off) : na
referenceEma = useReferenceAsset and not na(referenceClose) ? request.security(referenceSymbol, timeframe.period, ta.ema(close, trendEmaLength), lookahead=barmerge.lookahead_off) : na

// Trend filter with ATR buffer and reference asset correlation - using native chart data
trendFilterLevel = trendEma - (atr * trendAtrBuffer)
isTrendBullish = not trendFilterEnabled or close > trendFilterLevel
isReferenceBullish = not useReferenceAsset or (not na(referenceClose) and not na(referenceEma) and referenceClose > referenceEma)
isTrendFilterPassed = isTrendBullish and isReferenceBullish

// Swing pivot detection - find significant highs and lows that have been validated
pivotLookback = 10  // Look for pivots with 10 bars on each side
pivotHigh = ta.pivothigh(high, pivotLookback, pivotLookback)
pivotLow = ta.pivotlow(low, pivotLookback, pivotLookback)

// Track the most recent significant swing high/low
var float significantHigh = na
var float significantLow = na
var int significantHighTime = na
var int significantLowTime = na

// Update significant levels when new pivots are found
if not na(pivotHigh)
    significantHigh := pivotHigh
    significantHighTime := time[pivotLookback]  // Time when the pivot was actually formed

if not na(pivotLow)
    significantLow := pivotLow
    significantLowTime := time[pivotLookback]  // Time when the pivot was actually formed

// Use significant levels as HTF levels
htfHigh = significantHigh
htfLow = significantLow

// Data validation constants
contractDataValid = true

// Historical data sufficiency check (timeframe-aware)
maxLookbackRequired = math.max(trendEmaLength, atrLength, volatilityLookback)
historicalDataSufficient = bar_index >= maxLookbackRequired

// ROBUSTNESS FIX #3: Enhanced data validation (CRITICAL per pinescriptrules.txt)
basicDataValid = not na(close) and not na(high) and not na(low) and close > 0 and high > 0 and low > 0 and high >= low and high >= close and low <= close
atrDataValid = not na(atr) and atr > 0 and bar_index >= atrLength
trendDataValid = not na(trendEma) and trendEma > 0 and bar_index >= trendEmaLength
referenceDataValid = not useReferenceAsset or (not na(referenceClose) and not na(referenceEma) and referenceClose > 0)
htfDataValid = not na(htfHigh) and not na(htfLow) and htfHigh > 0 and htfLow > 0 and htfHigh > htfLow
mathSafetyValid = atr > 0 and close > 0 and strategy.equity > 0
isDataValid = basicDataValid and atrDataValid and trendDataValid and referenceDataValid and htfDataValid and historicalDataSufficient and contractDataValid and mathSafetyValid

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                E N T R Y   T R I G G E R S                                 |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// HTF-based entry system with day-based age validation

// Variables to track trade timing
var int crossAboveHTFHighTime = na
var int touchHTFLowTime = na

// Constants for time calculations
MILLISECONDS_PER_DAY = 86400000

// Track when we first cross above HTF high
if not na(htfHigh) and close > htfHigh and (na(crossAboveHTFHighTime) or close[1] <= htfHigh)
    crossAboveHTFHighTime := time

// Track when we first touch HTF low
if not na(htfLow) and low <= (htfLow * (1 + dipTouchBuffer / 100)) and na(touchHTFLowTime)
    touchHTFLowTime := time

// Calculate ages in days using pivot formation times
htfHighAgeDays = not na(significantHighTime) ? math.round((time - significantHighTime) / MILLISECONDS_PER_DAY) : na
htfLowAgeDays = not na(significantLowTime) ? math.round((time - significantLowTime) / MILLISECONDS_PER_DAY) : na
daysSinceCrossAbove = not na(crossAboveHTFHighTime) ? math.round((time - crossAboveHTFHighTime) / MILLISECONDS_PER_DAY) : na
daysSinceTouch = not na(touchHTFLowTime) ? math.round((time - touchHTFLowTime) / MILLISECONDS_PER_DAY) : na

// Breakout entry with age validation
basicBreakoutTrigger = enableBreakoutEntry and not na(htfHigh) and close > htfHigh
ageValidBreakout = na(htfHighAgeDays) or (htfHighAgeDays >= breakoutMinAgeDays and htfHighAgeDays <= breakoutMaxAgeDays)
crossWithinTimeframe = na(daysSinceCrossAbove) or daysSinceCrossAbove <= breakoutCrossWithinDays
breakoutTrigger = basicBreakoutTrigger and ageValidBreakout and crossWithinTimeframe

// Dip buy entry with recovery validation
touchedHTFLow = enableDipBuyEntry and not na(htfLow) and low <= (htfLow * (1 + dipTouchBuffer / 100))
dipRecoveryLevel = not na(htfLow) and not na(atr) ? htfLow + (atr * dipRecoveryBufferATR) : na
dipRecoveryTrigger = touchedHTFLow and not na(dipRecoveryLevel) and close > dipRecoveryLevel
ageValidDipBuy = na(htfLowAgeDays) or (htfLowAgeDays >= dipMinAgeDays and htfLowAgeDays <= dipMaxAgeDays)
recoveryWithinTimeframe = na(daysSinceTouch) or daysSinceTouch <= dipRecoveryWithinDays
dipBuyTrigger = dipRecoveryTrigger and ageValidDipBuy and recoveryWithinTimeframe

// Combined entry condition: ROBUSTNESS check AND DATA validation AND TREND filter AND REFERENCE asset AND (any entry trigger)
entryCondition = contractDataValid and isDataValid and isTrendFilterPassed and (breakoutTrigger or dipBuyTrigger)

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                    R I S K   M A N A G E M E N T                             |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Position sizing calculation
unitRiskAmountDollars = strategy.equity * (unitRiskPercent / 100.0)

// Dynamic volatility adjustment for trailing stops
avgAtr = ta.sma(atr, volatilityLookback)
volatilityAdjustment = enableDynamicTrail and not na(avgAtr) and avgAtr != 0 and not na(atr) and atr != 0 ? (atr / avgAtr > 1.2 ? 1.3 : atr / avgAtr < 0.8 ? 0.7 : 1.0) : 1.0

// Adjusted trail multiplier with dynamic volatility (WIDE TRAILS)
adjustedAtrTrailMultiplier = atrTrailMultiplier * volatilityAdjustment

// @function Calculate position size based on ATR risk
calculateUnitSize(entryPrice, stopLossPrice) =>
    if na(entryPrice) or na(stopLossPrice) or entryPrice <= 0 or stopLossPrice <= 0 or 
       unitRiskAmountDollars <= 0 or strategy.equity <= 0
        0.0
    else
        // Traditional position sizing (CFD/Spot style)
        riskPerShare = math.abs(entryPrice - stopLossPrice)
        if riskPerShare == 0
            0.0
        else
            unitValue = unitRiskAmountDollars / riskPerShare
            maxUnitValue = strategy.equity * 0.95
            validUnitValue = math.min(unitValue, maxUnitValue)
            math.floor(validUnitValue)

// @function Calculate ATR-based stop loss
calculateInitialStopLoss(entryPrice) =>
    if na(entryPrice) or entryPrice <= 0 or na(atr) or atr == 0
        na
    else
        atrStopPrice = entryPrice - (atr * stopLossMultiplier)
        math.min(atrStopPrice, entryPrice * 0.95)// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                    E X I T   S T R A T E G Y                                 |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Exit tracking variables
var float currentStopPrice = na
var float atrTrailStop = na
var float atrTrailHigh = na
var bool trailStartActivated = false
var float profitActivationLevel = na
var float initialStopPrice = na

// Update exit system with TOUCH HIGH activation mode (MTP KEY FEATURE) - now using baseTF data
if strategy.position_size > 0 and not na(atr)
    entryPrice = strategy.position_avg_price
    currentProfit = close - entryPrice
    profitInATR = atr != 0 ? currentProfit / atr : 0.0
    
    if na(initialStopPrice) and not na(currentStopPrice)
        initialStopPrice := currentStopPrice
    
    if exitMode == "ATR Trail"
        if na(profitActivationLevel)
            profitActivationLevel := entryPrice + (atr * trailStartProfitMultiplier)
        
        // MTP TOUCH HIGH MODE: Start trailing immediately on any new high above entry
        if not trailStartActivated
            if trailOnTouchHigh
                if high > entryPrice
                    trailStartActivated := true
                    atrTrailHigh := high
            else
                if close >= profitActivationLevel
                    trailStartActivated := true
                    atrTrailHigh := close
        
        // Update trailing stop with WIDE 22.5 ATR distance
        if trailStartActivated
            if high > atrTrailHigh
                atrTrailHigh := high
            
            newTrailStop = atrTrailHigh - (atr * adjustedAtrTrailMultiplier)
            
            if na(atrTrailStop)
                atrTrailStop := newTrailStop
            else
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
            
            if correlateUnit1TrailSL
                atrTrailStop := math.max(atrTrailStop, currentStopPrice)
            
            currentStopPrice := math.max(currentStopPrice, atrTrailStop)
else
    currentStopPrice := na
    atrTrailStop := na
    atrTrailHigh := na
    trailStartActivated := false
    profitActivationLevel := na
    initialStopPrice := na

// Exit conditions - now using baseTF data
stopLossHit = strategy.position_size > 0 and not na(currentStopPrice) and low <= currentStopPrice
trendFilterFail = strategy.position_size > 0 and not isTrendFilterPassed
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                             T R A D E   E X E C U T I O N                                   |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Pyramiding tracking
var int currentTierCount = 0
var float lastTierPrice = na

// Entry/Exit type tracking for UI labels
var string lastEntryType = na
var string lastExitType = na
var int lastEntryTier = na
var int lastExitTier = na

// Historical zone tracking
var array<box> historicalProfitZones = array.new<box>()
var array<box> historicalRiskZones = array.new<box>()

// Current active trade zone tracking
var box currentProfitZone = na
var box currentRiskZone = na
var int tradeStartBar = na
var float tradeEntryPrice = na
var float tradeExitPrice = na

// Entry execution with monthly data validation - now robust across timeframes and assets
if strategy.position_size == 0 and entryCondition and not na(atr) and atr != 0 and contractDataValid
    initialStop = calculateInitialStopLoss(close)
    if not na(initialStop) and initialStop < close
        unitSize = calculateUnitSize(close, initialStop)
        if unitSize > 0
            entryType = breakoutTrigger ? "F2B" : dipBuyTrigger ? "F3D" : "F2B"
            entryId = "T1-" + entryType
            
            strategy.entry(entryId, strategy.long, qty=unitSize)
            currentStopPrice := initialStop
            currentTierCount := 0
            lastTierPrice := na
            
            lastEntryType := entryType
            lastEntryTier := 1

// Initialize trade tracking for zones
if strategy.position_size > 0 and strategy.position_size[1] == 0
    tradeStartBar := bar_index
    tradeEntryPrice := strategy.position_avg_price// Pyramiding execution with correlation logic - now timeframe-robust
if enablePyramiding and strategy.position_size > 0 and currentTierCount < maxPyramidEntries and not na(atr) and atr != 0
    entryPrice = strategy.position_avg_price
    profitInN = atr != 0 ? (close - entryPrice) / atr : 0.0
    
    nextTierThreshold = (currentTierCount + 1) * pyramidSpacingATR
    
    atrThresholdMet = profitInN >= nextTierThreshold
    priceDistanceOk = na(lastTierPrice) or math.abs(close - lastTierPrice) >= (atr * pyramidSpacingATR)
    pyramidCondition = atrThresholdMet and priceDistanceOk
    
    currentTradeRisk = strategy.equity > 0 ? (strategy.position_size * math.abs(strategy.position_avg_price - currentStopPrice) / strategy.equity * 100) : 100.0
    wouldExceedMaxRisk = currentTradeRisk + unitRiskPercent > maxTradeRiskPercent
    
    if pyramidCondition and not wouldExceedMaxRisk
        tierStopPrice = calculateInitialStopLoss(close)
        
        if correlateAdditionalUnits
            tierStopPrice := math.max(tierStopPrice, currentStopPrice)
        
        tierSize = calculateUnitSize(close, tierStopPrice)
        
        if tierSize > 0
            entryType = breakoutTrigger ? "F2B" : dipBuyTrigger ? "F3D" : "F2B"
            tierNumber = currentTierCount + 2
            tierId = "T" + str.tostring(tierNumber) + "-" + entryType
            
            strategy.entry(tierId, strategy.long, qty=tierSize)
            currentTierCount := currentTierCount + 1
            lastTierPrice := close
            
            lastEntryType := entryType
            lastEntryTier := tierNumber
            
            if correlateAdditionalUnits
                currentStopPrice := math.max(currentStopPrice, tierStopPrice)
            else
                currentStopPrice := tierStopPrice
            
            if trailSLOnPyramiding and trailStartActivated
                newTrailStop = atrTrailHigh - (atr * adjustedAtrTrailMultiplier)
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
                currentStopPrice := math.max(currentStopPrice, atrTrailStop)

// Exit execution
if stopLossHit
    lastExitType := "F4E"
    lastExitTier := currentTierCount + 1
    exitComment = "T" + str.tostring(lastExitTier) + "-F4E"
    strategy.close_all(comment=exitComment)
else if trendFilterFail
    lastExitType := "F1E"
    lastExitTier := currentTierCount + 1
    exitComment = "T" + str.tostring(lastExitTier) + "-F1E"
    strategy.close_all(comment=exitComment)

// Reset tracking on position close
if strategy.position_size == 0
    currentTierCount := 0
    lastTierPrice := na
    if strategy.position_size[1] > 0
        lastEntryType := na
        lastEntryTier := na
        lastExitType := na
        lastExitTier := na
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                H I S T O R I C A L   Z O N E   M A N A G E M E N T                          |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Zone colors with user-configurable transparency
PROFIT_ZONE_COLOR = color.new(color.green, zoneTransparency)
RISK_ZONE_COLOR = color.new(color.red, zoneTransparency)
DARK_RED_LINE = color.new(color.red, 0)

// Historical zone constants
MAX_ZONES = maxHistoricalZones

// Zone array memory management (moved to main scope per Pine Script v6 requirements)
if array.size(historicalProfitZones) > MAX_ZONES
    oldBox = array.shift(historicalProfitZones)
    if not na(oldBox)
        box.delete(oldBox)

if array.size(historicalRiskZones) > MAX_ZONES
    oldBox = array.shift(historicalRiskZones)
    if not na(oldBox)
        box.delete(oldBox)

// Zone management for ACTIVE trades (per UI specifications)
if strategy.position_size > 0 and not na(currentStopPrice) and not na(tradeStartBar) and not na(tradeEntryPrice) and currentStopPrice > 0
    currentPrice = close
    upperBound = math.max(high * 1.05, currentPrice * 1.10)
    
    if showProfitZone and upperBound > tradeEntryPrice and tradeStartBar <= bar_index
        if na(currentProfitZone)
            currentProfitZone := box.new(left=tradeStartBar, top=upperBound, right=bar_index, bottom=tradeEntryPrice, bgcolor=PROFIT_ZONE_COLOR, border_color=color.new(color.green, 50), border_width=1, extend=extend.none)
        else
            box.set_right(currentProfitZone, bar_index)
            box.set_top(currentProfitZone, upperBound)
    
    if showRiskZone and tradeEntryPrice > currentStopPrice and currentStopPrice > 0 and tradeStartBar <= bar_index
        if na(currentRiskZone)
            currentRiskZone := box.new(left=tradeStartBar, top=tradeEntryPrice, right=bar_index, bottom=currentStopPrice, bgcolor=RISK_ZONE_COLOR, border_color=color.new(color.red, 50), border_width=1, extend=extend.none)
        else
            box.set_right(currentRiskZone, bar_index)
            box.set_bottom(currentRiskZone, currentStopPrice)

// Handle trade EXIT - finalize zones and preserve them historically
if strategy.position_size == 0 and strategy.position_size[1] > 0
    tradeExitPrice := close
    
    if showHistoricalZones
        if not na(currentProfitZone) and showProfitZone
            box.set_right(currentProfitZone, bar_index)
            array.push(historicalProfitZones, currentProfitZone)
            currentProfitZone := na
        
        if not na(currentRiskZone) and showRiskZone
            box.set_right(currentRiskZone, bar_index)
            array.push(historicalRiskZones, currentRiskZone)
            currentRiskZone := na
    
    if not showHistoricalZones
        if not na(currentProfitZone)
            box.delete(currentProfitZone)
            currentProfitZone := na
        if not na(currentRiskZone)
            box.delete(currentRiskZone)
            currentRiskZone := na
    
    tradeStartBar := na
    tradeEntryPrice := na

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                V I S U A L   I N T E R F A C E                             |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// UI Colors
BRIGHT_BLUE = color.new(#0080FF, 0)
BRIGHT_ORANGE = color.new(#FF8000, 0)
PROFESSIONAL_BLUE = color.new(color.blue, 20)
SUBTLE_GREEN = color.new(color.green, 97)// Essential plots
plot(showTrendEma ? trendEma : na, "100 EMA", color=PROFESSIONAL_BLUE, linewidth=1)

// Entry/Exit detection patterns
entryDetected = strategy.position_size > 0 and strategy.position_size[1] == 0
exitDetected = strategy.position_size == 0 and strategy.position_size[1] > 0

// Entry/Exit arrows
plotshape(showEntryArrows and entryDetected, "Entry Arrow", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.small)
plotshape(showExitArrows and exitDetected, "Exit Arrow", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.small)

// Background colors for trade zones
positionZone = strategy.position_size > 0
bgcolor(showStopLevels and positionZone ? SUBTLE_GREEN : na, title="Position Status")

// Performance metrics calculation (moved outside debug scope for Pine Script v6 compatibility)
totalReturnPct = strategy.equity > 0 ? ((strategy.equity - strategy.initial_capital) / strategy.initial_capital * 100) : 0
currentDrawdownPct = strategy.equity > 0 ? ((strategy.equity - strategy.max_equity) / strategy.max_equity * 100) : 0

// Annualized return calculation (fixed dynamic indexing violation)
var int startTime = na
if na(startTime)
    startTime := time

currentTime = time
daysInTest = not na(startTime) ? (currentTime - startTime) / (1000 * 60 * 60 * 24) : 1
yearsInTest = daysInTest / 365.25
equityMultiplier = strategy.equity > 0 and strategy.initial_capital > 0 ? strategy.equity / strategy.initial_capital : 1
annualizedReturnPct = yearsInTest > 0 and equityMultiplier > 0 ? (math.pow(equityMultiplier, 1/yearsInTest) - 1) * 100 : 0

// Debug information table with Universal HTF details and robustness indicators
if showDebugInfo
    // Simplified system validation
    historySufficient = bar_index >= math.max(breakoutLookback, dipLookback)
    
    debugTable = table.new(position.top_right, 2, 21, bgcolor=color.new(color.white, 80), border_width=1)
    table.cell(debugTable, 0, 0, "ðŸ›¡ï¸ JON", bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 0, "Values", bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.small)
    table.cell(debugTable, 0, 1, "Total Return %", text_size=size.small)
    table.cell(debugTable, 1, 1, str.tostring(totalReturnPct, "#.##") + "%", text_size=size.small)
    table.cell(debugTable, 0, 2, "Annualized %", text_size=size.small)
    table.cell(debugTable, 1, 2, str.tostring(annualizedReturnPct, "#.##") + "%", text_size=size.small)
    table.cell(debugTable, 0, 3, "Current DD %", text_size=size.small)
    table.cell(debugTable, 1, 3, str.tostring(currentDrawdownPct, "#.##") + "%", text_size=size.small)
    table.cell(debugTable, 0, 4, "Test Duration", text_size=size.small)
    table.cell(debugTable, 1, 4, str.tostring(yearsInTest, "#.##") + " years", text_size=size.small)
    table.cell(debugTable, 0, 5, "âš¡ Chart TF", text_size=size.small)
    table.cell(debugTable, 1, 5, timeframe.period, text_size=size.small)
    table.cell(debugTable, 0, 6, "âš¡ Breakout Lookback", text_size=size.small)
    table.cell(debugTable, 1, 6, str.tostring(breakoutLookback) + " bars", text_size=size.small)
    table.cell(debugTable, 0, 7, "âš¡ Dip Lookback", text_size=size.small)
    table.cell(debugTable, 1, 7, str.tostring(dipLookback) + " bars", text_size=size.small)
    table.cell(debugTable, 0, 8, "âš¡ History", text_size=size.small)
    table.cell(debugTable, 1, 8, str.tostring(bar_index) + " bars " + (historySufficient ? "âœ…" : "âš ï¸"), text_size=size.small)
    table.cell(debugTable, 0, 9, "Position Size", text_size=size.small)
    table.cell(debugTable, 1, 9, str.tostring(strategy.position_size, "##.##"), text_size=size.small)
    table.cell(debugTable, 0, 10, "Entry Price", text_size=size.small)
    table.cell(debugTable, 1, 10, not na(tradeEntryPrice) ? str.tostring(tradeEntryPrice, "##.##") : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 11, "Current Stop", text_size=size.small)
    table.cell(debugTable, 1, 11, not na(currentStopPrice) ? str.tostring(currentStopPrice, "##.##") : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 12, "ðŸ” ATR (50-period)", text_size=size.small)
    table.cell(debugTable, 1, 12, not na(atr) and atr != 0 ? str.tostring(atr, "##.####") : (na(atr) ? "NA" : "ZERO"), text_size=size.small)
    table.cell(debugTable, 0, 13, "ðŸ” Daily High", text_size=size.small)
    table.cell(debugTable, 1, 13, not na(htfHigh) ? str.tostring(htfHigh, "##.##") : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 14, "ðŸ” Daily Low", text_size=size.small)
    table.cell(debugTable, 1, 14, not na(htfLow) ? str.tostring(htfLow, "##.##") : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 15, "ðŸ” High Age", text_size=size.small)
    table.cell(debugTable, 1, 15, not na(htfHighAgeDays) ? str.tostring(htfHighAgeDays) + " days" : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 16, "ðŸ” Low Age", text_size=size.small)
    table.cell(debugTable, 1, 16, not na(htfLowAgeDays) ? str.tostring(htfLowAgeDays) + " days" : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 17, "ðŸ” Reference Asset", text_size=size.small)
    table.cell(debugTable, 1, 17, useReferenceAsset and not na(referenceClose) ? str.tostring(referenceClose, "##.##") : "Disabled", text_size=size.small)
    table.cell(debugTable, 0, 18, "ðŸ” Trail Distance", text_size=size.small)
    table.cell(debugTable, 1, 18, str.tostring(adjustedAtrTrailMultiplier, "#.#") + " ATR", text_size=size.small)
    table.cell(debugTable, 0, 19, "Trail Activated", text_size=size.small)
    table.cell(debugTable, 1, 19, trailStartActivated ? "YES" : "NO", text_size=size.small)
    table.cell(debugTable, 0, 20, "Data Valid", text_size=size.small)
    table.cell(debugTable, 1, 20, isDataValid ? "âœ…" : "âš ï¸", text_size=size.small)

// Plot Trailing Stop as a moving line that updates each bar
plot(strategy.position_size > 0 and not na(currentStopPrice) ? currentStopPrice : na, title="Trailing Stop", color=color.red, linewidth=2, style=plot.style_line)