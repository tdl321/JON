//@version=6
strategy("JON", shorttitle="JON", overlay=true, pyramiding=6, default_qty_type=strategy.fixed, initial_capital=100000, currency=currency.USD, commission_type=strategy.commission.percent, commission_value=0.1)

// === TREND FILTER ===
trendFilterEnabled = input.bool(true, "Enable 200 SMA Trend Filter", group = "Trend Filter")
trendSmaLength = input.int(200, "Trend SMA Length", minval = 50, maxval = 500, group = "Trend Filter")

// === BREAKOUT ENTRY ===
enableBreakoutEntry = input.bool(true, "Enable Breakout Entry", group = "Breakout Entry")
breakoutLookbackPeriod = input.int(30, "Breakout Lookback Period (bars)", minval = 10, maxval = 200, group = "Breakout Entry")
breakoutMinAgeDays = input.int(20, "Min Age of High (days)", minval = 1, maxval = 180, group = "Breakout Entry")
breakoutMaxAgeDays = input.int(200, "Max Age of High (days)", minval = 30, maxval = 1095, group = "Breakout Entry")
breakoutCrossWithinDays = input.int(20, "Cross Above Within (days)", minval = 1, maxval = 60, group = "Breakout Entry")

// === DIP BUY ENTRY ===
enableDipBuyEntry = input.bool(true, "Enable Dip Buy Entry", group = "Dip Buy Entry")
dipLookbackPeriod = input.int(30, "Dip Lookback Period (bars)", minval = 10, maxval = 200, group = "Dip Buy Entry")
dipRecoveryWithinDays = input.int(30, "Recovery Within (days)", minval = 7, maxval = 180, group = "Dip Buy Entry")
dipMinAgeDays = input.int(15, "Min Age of Low (days)", minval = 1, maxval = 180, group = "Dip Buy Entry")
dipMaxAgeDays = input.int(90, "Max Age of Low (days)", minval = 21, maxval = 730, group = "Dip Buy Entry")
dipRecoveryBufferATR = input.float(0.4, "Recovery Buffer (ATR)", minval = 0.1, maxval = 1.0, step = 0.05, group = "Dip Buy Entry")

// === EXIT STRATEGY ===
initialStopMultiplier = input.float(2.0, "Initial Stop Distance x ATR", minval = 0.5, maxval = 25.0, step = 0.5, group = "Exit Strategy")
trailingStopMultiplier = input.float(3.0, "Trailing Stop Distance x ATR", minval = 0.5, maxval = 50.0, step = 0.5, group = "Exit Strategy")
profitThresholdATR = input.float(1.5, "Profit Threshold for Trailing", minval = 1.0, maxval = 20.0, step = 0.1, group = "Exit Strategy")

// === RISK MANAGEMENT ===
atrLength = input.int(100, "ATR Length", minval = 5, maxval = 200, group = "Risk Management")

// === PYRAMIDING ===
enablePyramiding = input.bool(true, "Enable Unit Pyramiding", group = "Pyramiding")
maxPyramidEntries = input.int(5, "Max Additional Units", minval = 1, maxval = 5, group = "Pyramiding")
pyramidSpacingATR = input.float(0.25, "Unit Spacing (ATR)", minval = 0.25, maxval = 2.0, step = 0.25, group = "Pyramiding")

// === DISPLAY ===
showTrendSma = input.bool(true, "Show 200 SMA", group = "Display")
showStopLevels = input.bool(true, "Show Stop Loss Line", group = "Display")

// === CORE INDICATORS ===
atr = ta.atr(atrLength)
trendSma = ta.sma(close, trendSmaLength)

// === FILTERS ===
// Use current data for entry decisions (slight repainting acceptable for responsiveness)
isTrendBullish = not trendFilterEnabled or close > trendSma

// === CURRENT TIMEFRAME DATA ===
breakoutHigh = ta.highest(high[1], breakoutLookbackPeriod)
dipLow = ta.lowest(low[1], dipLookbackPeriod)

// === TIMING TRACKING ===
var float lastHigh = na
var float lastLow = na
var int highChangeTime = na
var int lowChangeTime = na
var int touchLowTime = na
var int crossHighTime = na

// Track level changes
if not na(breakoutHigh) and (na(lastHigh) or breakoutHigh != lastHigh)
    lastHigh := breakoutHigh
    highChangeTime := time[1]

if not na(dipLow) and (na(lastLow) or dipLow != lastLow)
    lastLow := dipLow
    lowChangeTime := time[1]
    touchLowTime := na

// Track timing events
if not na(dipLow) and low[1] <= dipLow and (na(touchLowTime) or (time - touchLowTime) / 86400000 > dipRecoveryWithinDays)
    touchLowTime := time[1]

if not na(breakoutHigh) and close > breakoutHigh and (na(crossHighTime) or (time - crossHighTime) / 86400000 > breakoutCrossWithinDays)
    crossHighTime := time

// === ENTRY TRIGGERS ===
// Age validation
highAgeDays = not na(highChangeTime) ? math.round((time - highChangeTime) / 86400000) : na
lowAgeDays = not na(lowChangeTime) ? math.round((time - lowChangeTime) / 86400000) : na
daysSinceTouch = not na(touchLowTime) ? math.round((time - touchLowTime) / 86400000) : na
daysSinceCross = not na(crossHighTime) ? math.round((time - crossHighTime) / 86400000) : na

// Breakout entry with timing window - hybrid approach
basicBreakoutTrigger = enableBreakoutEntry and not na(breakoutHigh) and close > breakoutHigh
ageValidBreakout = na(highAgeDays) or (highAgeDays >= breakoutMinAgeDays and highAgeDays <= breakoutMaxAgeDays)
crossWithinTimeframe = na(daysSinceCross) or daysSinceCross <= breakoutCrossWithinDays
breakoutTrigger = basicBreakoutTrigger and ageValidBreakout and crossWithinTimeframe

// Dip buy entry with timing window - hybrid approach  
touchedLow = enableDipBuyEntry and not na(dipLow) and low <= dipLow
dipRecoveryLevel = not na(dipLow) and not na(atr) ? dipLow + (atr * dipRecoveryBufferATR) : na
dipRecoveryTrigger = touchedLow and not na(dipRecoveryLevel) and close > dipRecoveryLevel
ageValidDipBuy = na(lowAgeDays) or (lowAgeDays >= dipMinAgeDays and lowAgeDays <= dipMaxAgeDays)
recoveryWithinTimeframe = na(daysSinceTouch) or daysSinceTouch <= dipRecoveryWithinDays
dipBuyTrigger = dipRecoveryTrigger and ageValidDipBuy and recoveryWithinTimeframe

// Combined entry
entryCondition = isTrendBullish and (breakoutTrigger or dipBuyTrigger) and not na(atr) and atr > 0
entryType = breakoutTrigger ? "BO" : dipBuyTrigger ? "DIP" : na

// === POSITION SIZING ===
calculatePositionSize() =>
    equity = strategy.equity
    positionValue = equity * 0.65
    math.floor(positionValue / close)

// === EXIT MANAGEMENT ===
var float currentStopPrice = na
var float trailHigh = na
var bool trailingActivated = false
var int currentTierCount = 0
var float lastTierPrice = na

calculateInitialStopLoss(entryPrice) =>
    if na(entryPrice) or entryPrice <= 0 or na(atr) or atr == 0
        na
    else
        entryPrice - (atr * initialStopMultiplier)

// === TRADE EXECUTION ===
// Entry with debug
if strategy.position_size == 0 and entryCondition
    initialStop = calculateInitialStopLoss(close)
    if not na(initialStop) and initialStop < close
        posSize = calculatePositionSize()
        if posSize > 0
            entryId = "T1-" + entryType
            strategy.entry(entryId, strategy.long, qty=posSize)
            currentStopPrice := initialStop
            currentTierCount := 0
            lastTierPrice := na
            // Debug alert
            alert("ENTRY: " + entryType + " at " + str.tostring(close, "#.##") + " | STOP SET: " + str.tostring(currentStopPrice, "#.##"), alert.freq_once_per_bar)

// Pyramiding
if enablePyramiding and strategy.position_size > 0 and currentTierCount < maxPyramidEntries and not na(atr) and atr != 0
    entryPrice = strategy.position_avg_price
    profitInN = atr != 0 ? (close - entryPrice) / atr : 0.0
    nextTierThreshold = (currentTierCount + 1) * pyramidSpacingATR
    
    atrThresholdMet = profitInN >= nextTierThreshold
    priceDistanceOk = na(lastTierPrice) or math.abs(close - lastTierPrice) >= (atr * pyramidSpacingATR)
    
    if atrThresholdMet and priceDistanceOk
        tierStopPrice = calculateInitialStopLoss(close)
        tierStopPrice := math.max(tierStopPrice, currentStopPrice)
        tierSize = calculatePositionSize()
        
        if tierSize > 0
            tierNumber = currentTierCount + 2
            tierId = "T" + str.tostring(tierNumber) + "-" + entryType
            strategy.entry(tierId, strategy.long, qty=tierSize)
            currentTierCount := currentTierCount + 1
            lastTierPrice := close
            currentStopPrice := math.max(currentStopPrice, tierStopPrice)

// Simple stop management - AFTER trade execution
if strategy.position_size > 0 and not na(atr) and not na(currentStopPrice)
    entryPrice = strategy.position_avg_price
    profitInATR = (close - entryPrice) / atr
    
    // Activate trailing when profitable enough
    if not trailingActivated and profitInATR >= profitThresholdATR
        trailingActivated := true
        trailHigh := high
    
    // Update trailing stop
    if trailingActivated
        if high > trailHigh
            trailHigh := high
        newStop = trailHigh - (atr * trailingStopMultiplier)
        currentStopPrice := math.max(currentStopPrice, newStop)

// Exit conditions - AFTER stop management so they use updated values
stopLossHit = strategy.position_size > 0 and not na(currentStopPrice) and low <= currentStopPrice
trendFilterFail = strategy.position_size > 0 and not isTrendBullish

// Exit with debug alerts
if stopLossHit
    alert("STOP LOSS HIT: Price " + str.tostring(low, "#.##") + " below stop " + str.tostring(currentStopPrice, "#.##"), alert.freq_once_per_bar)
    strategy.close_all(comment="STOP")
else if trendFilterFail
    alert("TREND FILTER EXIT: Price " + str.tostring(close, "#.##") + " below SMA " + str.tostring(trendSma, "#.##"), alert.freq_once_per_bar)
    strategy.close_all(comment="TREND")

// Reset on position close - SIMPLE
if strategy.position_size == 0
    currentTierCount := 0
    lastTierPrice := na
    currentStopPrice := na
    trailHigh := na
    trailingActivated := false

// === VISUALS ===
plot(showTrendSma ? trendSma : na, "200 SMA", color=color.blue, linewidth=1)
plot(strategy.position_size > 0 and not na(currentStopPrice) ? currentStopPrice : na, "Stop Loss", color=color.red, linewidth=2)

// Entry/Exit markers
plotshape(strategy.position_size > 0 and strategy.position_size[1] == 0, "Entry", shape.arrowup, location.belowbar, color.green, size=size.small)
plotshape(strategy.position_size == 0 and strategy.position_size[1] > 0, "Exit", shape.arrowdown, location.abovebar, color.red, size=size.small)



