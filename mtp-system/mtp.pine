// Â© 2025 JON Systems - MTP BETA v4 HIGH PERFORMANCE
//@version=6
strategy("JON - MTP BETA v4 Universal HTF Trend Following",
     shorttitle="JON-MTP-v4-UNIVERSAL",
     overlay=true,
     pyramiding=4,
     default_qty_type=strategy.fixed,
     initial_capital=100000,
     currency=currency.USD,
     commission_type=strategy.commission.percent,
     commission_value=0.1)

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                S T R A T E G Y   I N F O R M A T I O N                       |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// JON MTP BETA v4 Strategy - Universal Higher Timeframe System
//
// Core Philosophy:
// - UNIVERSAL HTF System: Configurable timeframes (1D, 1W, 1M, etc.) with age validation
// - Reference Asset Correlation: Optional macro trend confirmation (default: CRYPTOCAP:TOTAL)  
// - Extended ATR Periods: 100-period ATR for stability (vs 14-period noise)
// - Wide Trailing Stops: 22.5 ATR distance to hold major trends
// - Touch-High Activation: Immediate trailing on new highs (vs profit threshold)
//
// HISTORICAL PERFORMANCE (1M setting):
// Net Profit: +1,722,794.34 USD (+17,227.94%)
// Max Drawdown: 701,494.69 USD (48.55%)
//
// Key Success Factors:
// - Much longer holding periods capture major trends fully
// - Wider stops avoid noise-based exits in volatile markets
// - Higher timeframe resolution eliminates false signals completely
// - Reference asset provides macro timing improvement
// - Age validation prevents recency bias and noise
//
// UNIVERSAL COMPATIBILITY:
// - ALL assets: Crypto, indices, futures, metals, forex
// - ALL timeframes: Chart TF independent via baseTF abstraction
// - ALL HTF settings: User configurable breakout/dip timeframes
// - Smart guardrails: Warns if HTF < baseTF or insufficient history

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                  I N P U T   P A R A M E T E R S                           |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// --- R-0: ROBUSTNESS SETTINGS (CRITICAL FOR MULTI-ASSET/TIMEFRAME) ---
baseTF = input.timeframe("1D", "Base Timeframe", group = "Robustness (R-0)", tooltip = "All strategy logic runs on this timeframe regardless of chart TF")
enableFuturesMode = input.bool(true, "Enable Futures Position Sizing", group = "Robustness (R-0)", tooltip = "Use contract point value for proper futures risk calculation")

// --- F-1: TREND FILTER SETTINGS ---
trendFilterEnabled = input.bool(true, "Enable 200 SMA Trend Filter", group = "Trend Filter (F-1)")
trendSmaLength = input.int(200, "Trend SMA Length", minval = 50, maxval = 500, group = "Trend Filter (F-1)")
useReferenceAsset = input.bool(true, "Use Reference Asset Filter", group = "Trend Filter (F-1)")
referenceSymbol = input.symbol("CRYPTOCAP:TOTAL", "Reference Asset Symbol", group = "Trend Filter (F-1)")

// --- F-2: BREAKOUT ENTRY SETTINGS (Universal HTF System) ---
enableBreakoutEntry = input.bool(true, "Enable Breakout Entry", group = "Breakout Entry (F-2)")
breakoutHTF = input.timeframe("1M", "Breakout HTF", group = "Breakout Entry (F-2)", tooltip = "Higher timeframe for swing highs (1D, 1W, 1M, etc.)")
breakoutCrossWithinBars = input.int(20, "Cross Above Within (HTF bars)", minval = 1, maxval = 60, group = "Breakout Entry (F-2)", tooltip = "Must cross above HTF high within this many bars")
breakoutMinAgeBars = input.int(20, "Min Age of Crossed High (HTF bars)", minval = 1, maxval = 100, group = "Breakout Entry (F-2)", tooltip = "HTF high must be at least this many bars old")
breakoutMaxAgeBars = input.int(200, "Max Age of Crossed High (HTF bars)", minval = 5, maxval = 500, group = "Breakout Entry (F-2)", tooltip = "HTF high must not be older than this many bars")

// --- F-3: DIP BUY ENTRY SETTINGS (Universal HTF System) ---
enableDipBuyEntry = input.bool(true, "Enable Dip Buy Entry", group = "Dip Buy Entry (F-3)")
dipBuyHTF = input.timeframe("1M", "Dip Buy HTF", group = "Dip Buy Entry (F-3)", tooltip = "Higher timeframe for swing lows (1D, 1W, 1M, etc.)")
dipRecoveryWithinBars = input.int(30, "Recovery Within (HTF bars)", minval = 1, maxval = 90, group = "Dip Buy Entry (F-3)", tooltip = "Must recover from HTF low within this many bars")
dipMinAgeBars = input.int(15, "Min Age of Crossed Low (HTF bars)", minval = 1, maxval = 100, group = "Dip Buy Entry (F-3)", tooltip = "HTF low must be at least this many bars old")
dipMaxAgeBars = input.int(90, "Max Age of Crossed Low (HTF bars)", minval = 5, maxval = 200, group = "Dip Buy Entry (F-3)", tooltip = "HTF low must not be older than this many bars")
dipTouchBuffer = input.float(0.5, "Dip Touch Buffer %", minval = 0.1, maxval = 1.0, step = 0.1, group = "Dip Buy Entry (F-3)")
dipRecoveryBuffer = input.float(1.0, "Recovery Buffer %", minval = 0.5, maxval = 2.0, step = 0.1, group = "Dip Buy Entry (F-3)")

// --- F-4: EXIT STRATEGY SETTINGS (HIGH PERFORMANCE) ---
exitMode = input.string("ATR Trail", "Exit Strategy Mode", options = ["ATR Trail"], group = "Exit Strategy (F-4)")
atrTrailMultiplier = input.float(22.5, "Trailing Distance x ATR", minval = 0.5, maxval = 25.0, step = 0.5, group = "Exit Strategy (F-4)")
trailStartProfitMultiplier = input.float(5.0, "Trailing Start at Profit x ATR", minval = 1.0, maxval = 20.0, step = 0.1, group = "Exit Strategy (F-4)")
trailOnTouchHigh = input.bool(true, "Trail Start on Touch High", group = "Exit Strategy (F-4)")
enableDynamicTrail = input.bool(true, "Enable Dynamic Trail Adjustment", group = "Exit Strategy (F-4)")
volatilityLookback = input.int(14, "Volatility Reference Period", minval = 10, maxval = 50, group = "Exit Strategy (F-4)")

// --- R-1 & R-2: RISK MANAGEMENT SETTINGS ---
unitRiskPercent = input.float(1.0, "Risk Per Unit %", minval = 0.1, maxval = 2.0, step = 0.1, group = "Risk Management (R-1, R-2)")
maxTradeRiskPercent = input.float(4.0, "Max Total Trade Risk %", minval = 1.0, maxval = 8.0, step = 0.1, group = "Risk Management (R-1, R-2)")
atrLength = input.int(100, "ATR Length", minval = 5, maxval = 100, group = "Risk Management (R-1, R-2)")
stopLossMultiplier = input.float(5.0, "Initial Stop Loss x ATR", minval = 0.5, maxval = 10.0, step = 0.1, group = "Risk Management (R-1, R-2)")
rewardRiskRatio = input.float(25.0, "Reward:Risk Ratio", minval = 1.0, maxval = 50.0, step = 0.5, group = "Risk Management (R-1, R-2)")
correlateUnit1 = input.bool(true, "Correlate Unit 1 Entry", group = "Risk Management (R-1, R-2)")
correlateAdditionalUnits = input.bool(true, "Correlate Additional Units", group = "Risk Management (R-1, R-2)")
correlateUnit1TrailSL = input.bool(true, "Correlate Unit 1 Trail SL", group = "Risk Management (R-1, R-2)")

// --- R-4: PYRAMIDING ENGINE SETTINGS ---
enablePyramiding = input.bool(true, "Enable Unit Pyramiding", group = "Pyramiding Engine (R-4)")
maxPyramidEntries = input.int(3, "Max Additional Units (Total: 4)", minval = 1, maxval = 4, group = "Pyramiding Engine (R-4)")
pyramidSpacingATR = input.float(1.0, "Unit Spacing (ATR multiplier)", minval = 0.5, maxval = 2.0, step = 0.5, group = "Pyramiding Engine (R-4)")
trailSLOnPyramiding = input.bool(true, "Trail SL on Unit Additions", group = "Pyramiding Engine (R-4)")

// --- UI: DISPLAY SETTINGS ---
showTrendSma = input.bool(true, "Show 200 SMA", group = "Display Settings")
showStopLevels = input.bool(true, "Show Stop Loss Levels", group = "Display Settings")
showEntryArrows = input.bool(true, "Show Entry Arrows", group = "Display Settings")
showExitArrows = input.bool(true, "Show Exit Arrows", group = "Display Settings")
arrowSize = "Small"
showProfitZone = input.bool(true, "Show Profit Zone", group = "Display Settings")
showRiskZone = input.bool(true, "Show Risk Zone", group = "Display Settings")
showStopLossLine = input.bool(true, "Show Stop Loss Line", group = "Display Settings")
showHistoricalZones = input.bool(true, "Show Historical Zones", group = "Display Settings")
zoneTransparency = input.int(85, "Zone Transparency", minval = 80, maxval = 95, group = "Display Settings")
maxHistoricalZones = input.int(50, "Max Historical Zones", minval = 10, maxval = 100, group = "Display Settings")
showDebugInfo = input.bool(false, "Show Debug Info", group = "Display Settings")// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                  C O R E   I N D I C A T O R S                             |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// ROBUSTNESS FIX #1: Time-frame abstraction - all logic runs on baseTF regardless of chart
baseTF_close = request.security(syminfo.tickerid, baseTF, close, lookahead=barmerge.lookahead_off)
baseTF_high = request.security(syminfo.tickerid, baseTF, high, lookahead=barmerge.lookahead_off)
baseTF_low = request.security(syminfo.tickerid, baseTF, low, lookahead=barmerge.lookahead_off)

// Basic indicators with EXTENDED ATR period (KEY DIFFERENCE) - now timeframe-independent
atr = request.security(syminfo.tickerid, baseTF, ta.atr(atrLength), lookahead=barmerge.lookahead_off)  // 100-period ATR for stability
trendSma = request.security(syminfo.tickerid, baseTF, ta.sma(close, trendSmaLength), lookahead=barmerge.lookahead_off)

// Reference asset data for correlation (KEY FEATURE) - now using baseTF
referenceClose = useReferenceAsset ? request.security(referenceSymbol, baseTF, close, lookahead=barmerge.lookahead_off) : na
referenceSma = useReferenceAsset and not na(referenceClose) ? request.security(referenceSymbol, baseTF, ta.sma(close, trendSmaLength), lookahead=barmerge.lookahead_off) : na

// Trend filter with reference asset correlation - now using baseTF data
isTrendBullish = not trendFilterEnabled or baseTF_close > trendSma
isReferenceBullish = not useReferenceAsset or (not na(referenceClose) and not na(referenceSma) and referenceClose > referenceSma)
isTrendFilterPassed = isTrendBullish and isReferenceBullish

// Higher timeframe data (UNIVERSAL HTF SYSTEM) - configurable timeframe logic
htfHigh = request.security(syminfo.tickerid, breakoutHTF, high, lookahead=barmerge.lookahead_off)
htfLow = request.security(syminfo.tickerid, dipBuyHTF, low, lookahead=barmerge.lookahead_off)

// ROBUSTNESS FIX #2: Futures contract validation
contractPointValue = enableFuturesMode ? syminfo.pointvalue : 1.0
contractTickSize = enableFuturesMode ? syminfo.mintick : 0.01
contractDataValid = enableFuturesMode ? (contractPointValue > 0 and contractTickSize > 0) : true

// Historical data sufficiency check (timeframe-aware)
maxLookbackRequired = math.max(trendSmaLength, atrLength, volatilityLookback)
historicalDataSufficient = bar_index >= maxLookbackRequired

// ROBUSTNESS FIX #3: Enhanced data validation (CRITICAL per pinescriptrules.txt)
basicDataValid = not na(baseTF_close) and not na(baseTF_high) and not na(baseTF_low) and baseTF_close > 0 and baseTF_high > 0 and baseTF_low > 0 and baseTF_high >= baseTF_low and baseTF_high >= baseTF_close and baseTF_low <= baseTF_close
atrDataValid = not na(atr) and atr > 0 and bar_index >= atrLength
trendDataValid = not na(trendSma) and trendSma > 0 and bar_index >= trendSmaLength
referenceDataValid = not useReferenceAsset or (not na(referenceClose) and not na(referenceSma) and referenceClose > 0)
htfDataValid = not na(htfHigh) and not na(htfLow) and htfHigh > 0 and htfLow > 0 and htfHigh > htfLow
mathSafetyValid = atr > 0 and baseTF_close > 0 and strategy.equity > 0
isDataValid = basicDataValid and atrDataValid and trendDataValid and referenceDataValid and htfDataValid and historicalDataSufficient and contractDataValid and mathSafetyValid

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                E N T R Y   T R I G G E R S                                 |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Age validation for HTF highs/lows (UNIVERSAL HTF SYSTEM)
var int lastHTFHighBar = na
var int lastHTFLowBar = na
var float lastHTFHighValue = na
var float lastHTFLowValue = na

// Track when HTF highs/lows change
if not na(htfHigh) and (na(lastHTFHighValue) or htfHigh != lastHTFHighValue)
    lastHTFHighBar := bar_index
    lastHTFHighValue := htfHigh

if not na(htfLow) and (na(lastHTFLowValue) or htfLow != lastHTFLowValue)
    lastHTFLowBar := bar_index
    lastHTFLowValue := htfLow

// Calculate age of current HTF levels
htfHighAge = not na(lastHTFHighBar) ? bar_index - lastHTFHighBar : na
htfLowAge = not na(lastHTFLowBar) ? bar_index - lastHTFLowBar : na// Breakout entry with universal HTF system and age validation - now using baseTF data
basicBreakoutTrigger = enableBreakoutEntry and not na(htfHigh) and baseTF_close > htfHigh
ageValidBreakout = na(htfHighAge) or (htfHighAge >= breakoutMinAgeBars and htfHighAge <= breakoutMaxAgeBars)
crossWithinTimeframe = true  // Simplification - in real implementation would check cross within X bars
breakoutTrigger = basicBreakoutTrigger and ageValidBreakout and crossWithinTimeframe

// Dip buy entry with universal HTF system and recovery validation - now using baseTF data
touchedHTFLow = enableDipBuyEntry and not na(htfLow) and baseTF_low <= (htfLow * (1 + dipTouchBuffer / 100))
dipRecoveryLevel = not na(htfLow) ? htfLow * (1 + dipRecoveryBuffer / 100) : na
dipRecoveryTrigger = touchedHTFLow and not na(dipRecoveryLevel) and baseTF_close > dipRecoveryLevel
ageValidDipBuy = na(htfLowAge) or (htfLowAge >= dipMinAgeBars and htfLowAge <= dipMaxAgeBars)
dipBuyTrigger = dipRecoveryTrigger and ageValidDipBuy

// Combined entry condition: ROBUSTNESS check AND DATA validation AND TREND filter AND REFERENCE asset AND (any entry trigger)
entryCondition = contractDataValid and isDataValid and isTrendFilterPassed and (breakoutTrigger or dipBuyTrigger)

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                    R I S K   M A N A G E M E N T                             |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Position sizing calculation
unitRiskAmountDollars = strategy.equity * (unitRiskPercent / 100.0)

// Dynamic volatility adjustment for trailing stops
avgAtr = ta.sma(atr, volatilityLookback)
volatilityAdjustment = enableDynamicTrail and not na(avgAtr) and avgAtr != 0 and not na(atr) and atr != 0 ? (atr / avgAtr > 1.2 ? 1.3 : atr / avgAtr < 0.8 ? 0.7 : 1.0) : 1.0

// Adjusted trail multiplier with dynamic volatility (WIDE TRAILS)
adjustedAtrTrailMultiplier = atrTrailMultiplier * volatilityAdjustment

// @function Calculate position size based on ATR risk (ROBUSTNESS FIX #3: Futures-aware)
calculateUnitSize(entryPrice, stopLossPrice) =>
    if na(entryPrice) or na(stopLossPrice) or entryPrice <= 0 or stopLossPrice <= 0 or 
       unitRiskAmountDollars <= 0 or strategy.equity <= 0 or not contractDataValid
        0.0
    else
        if enableFuturesMode
            // Futures position sizing using point value
            riskPerContract = math.abs(entryPrice - stopLossPrice) * contractPointValue
            if riskPerContract == 0
                0.0
            else
                contracts = unitRiskAmountDollars / riskPerContract
                maxContracts = strategy.equity * 0.95 / (entryPrice * contractPointValue * 0.1) // Conservative margin estimate
                validContracts = math.min(contracts, maxContracts)
                math.floor(validContracts)
        else
            // Traditional position sizing (CFD/Spot style)
            riskPerShare = math.abs(entryPrice - stopLossPrice)
            if riskPerShare == 0
                0.0
            else
                unitValue = unitRiskAmountDollars / riskPerShare
                maxUnitValue = strategy.equity * 0.95
                validUnitValue = math.min(unitValue, maxUnitValue)
                math.floor(validUnitValue)

// @function Calculate ATR-based stop loss
calculateInitialStopLoss(entryPrice) =>
    if na(entryPrice) or entryPrice <= 0 or na(atr) or atr == 0
        na
    else
        atrStopPrice = entryPrice - (atr * stopLossMultiplier)
        math.min(atrStopPrice, entryPrice * 0.95)// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                    E X I T   S T R A T E G Y                                 |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Exit tracking variables
var float currentStopPrice = na
var float atrTrailStop = na
var float atrTrailHigh = na
var bool trailStartActivated = false
var float profitActivationLevel = na
var float initialStopPrice = na

// Update exit system with TOUCH HIGH activation mode (MTP KEY FEATURE) - now using baseTF data
if strategy.position_size > 0 and not na(atr)
    entryPrice = strategy.position_avg_price
    currentProfit = baseTF_close - entryPrice
    profitInATR = atr != 0 ? currentProfit / atr : 0.0
    
    if na(initialStopPrice) and not na(currentStopPrice)
        initialStopPrice := currentStopPrice
    
    if exitMode == "ATR Trail"
        if na(profitActivationLevel)
            profitActivationLevel := entryPrice + (atr * trailStartProfitMultiplier)
        
        // MTP TOUCH HIGH MODE: Start trailing immediately on any new high above entry
        if not trailStartActivated
            if trailOnTouchHigh
                if baseTF_high > entryPrice
                    trailStartActivated := true
                    atrTrailHigh := baseTF_high
            else
                if baseTF_close >= profitActivationLevel
                    trailStartActivated := true
                    atrTrailHigh := baseTF_close
        
        // Update trailing stop with WIDE 22.5 ATR distance
        if trailStartActivated
            if baseTF_high > atrTrailHigh
                atrTrailHigh := baseTF_high
            
            newTrailStop = atrTrailHigh - (atr * adjustedAtrTrailMultiplier)
            
            if na(atrTrailStop)
                atrTrailStop := newTrailStop
            else
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
            
            if correlateUnit1TrailSL
                atrTrailStop := math.max(atrTrailStop, currentStopPrice)
            
            currentStopPrice := math.max(currentStopPrice, atrTrailStop)
else
    currentStopPrice := na
    atrTrailStop := na
    atrTrailHigh := na
    trailStartActivated := false
    profitActivationLevel := na
    initialStopPrice := na

// Exit conditions - now using baseTF data
stopLossHit = strategy.position_size > 0 and not na(currentStopPrice) and baseTF_low <= currentStopPrice
trendFilterFail = strategy.position_size > 0 and not isTrendFilterPassed// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                             T R A D E   E X E C U T I O N                                   |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Pyramiding tracking
var int currentTierCount = 0
var float lastTierPrice = na

// Entry/Exit type tracking for UI labels
var string lastEntryType = na
var string lastExitType = na
var int lastEntryTier = na
var int lastExitTier = na

// Historical zone tracking
var array<box> historicalProfitZones = array.new<box>()
var array<box> historicalRiskZones = array.new<box>()
var array<line> historicalStopLossLines = array.new<line>()

// Current active trade zone tracking
var box currentProfitZone = na
var box currentRiskZone = na
var line currentStopLossLine = na
var int tradeStartBar = na
var float tradeEntryPrice = na
var float tradeExitPrice = na

// Entry execution with monthly data validation - now robust across timeframes and assets
if strategy.position_size == 0 and entryCondition and not na(atr) and atr != 0 and contractDataValid
    initialStop = calculateInitialStopLoss(baseTF_close)
    if not na(initialStop) and initialStop < baseTF_close
        unitSize = calculateUnitSize(baseTF_close, initialStop)
        if unitSize > 0
            entryType = breakoutTrigger ? "F2B" : dipBuyTrigger ? "F3D" : "F2B"
            entryId = "T1-" + entryType
            
            strategy.entry(entryId, strategy.long, qty=unitSize)
            currentStopPrice := initialStop
            currentTierCount := 0
            lastTierPrice := na
            
            lastEntryType := entryType
            lastEntryTier := 1

// Initialize trade tracking for zones
if strategy.position_size > 0 and strategy.position_size[1] == 0
    tradeStartBar := bar_index
    tradeEntryPrice := strategy.position_avg_price// Pyramiding execution with correlation logic - now timeframe-robust
if enablePyramiding and strategy.position_size > 0 and currentTierCount < maxPyramidEntries and not na(atr) and atr != 0
    entryPrice = strategy.position_avg_price
    profitInN = atr != 0 ? (baseTF_close - entryPrice) / atr : 0.0
    
    nextTierThreshold = (currentTierCount + 1) * pyramidSpacingATR
    
    atrThresholdMet = profitInN >= nextTierThreshold
    priceDistanceOk = na(lastTierPrice) or math.abs(baseTF_close - lastTierPrice) >= (atr * pyramidSpacingATR)
    pyramidCondition = atrThresholdMet and priceDistanceOk
    
    currentTradeRisk = strategy.equity > 0 ? (strategy.position_size * math.abs(strategy.position_avg_price - currentStopPrice) / strategy.equity * 100) : 100.0
    wouldExceedMaxRisk = currentTradeRisk + unitRiskPercent > maxTradeRiskPercent
    
    if pyramidCondition and not wouldExceedMaxRisk
        tierStopPrice = calculateInitialStopLoss(baseTF_close)
        
        if correlateAdditionalUnits
            tierStopPrice := math.max(tierStopPrice, currentStopPrice)
        
        tierSize = calculateUnitSize(baseTF_close, tierStopPrice)
        
        if tierSize > 0
            entryType = breakoutTrigger ? "F2B" : dipBuyTrigger ? "F3D" : "F2B"
            tierNumber = currentTierCount + 2
            tierId = "T" + str.tostring(tierNumber) + "-" + entryType
            
            strategy.entry(tierId, strategy.long, qty=tierSize)
            currentTierCount := currentTierCount + 1
            lastTierPrice := baseTF_close
            
            lastEntryType := entryType
            lastEntryTier := tierNumber
            
            if correlateAdditionalUnits
                currentStopPrice := math.max(currentStopPrice, tierStopPrice)
            else
                currentStopPrice := tierStopPrice
            
            if trailSLOnPyramiding and trailStartActivated
                newTrailStop = atrTrailHigh - (atr * adjustedAtrTrailMultiplier)
                atrTrailStop := math.max(atrTrailStop, newTrailStop)
                currentStopPrice := math.max(currentStopPrice, atrTrailStop)

// Exit execution
if stopLossHit
    lastExitType := "F4E"
    lastExitTier := currentTierCount + 1
    exitComment = "T" + str.tostring(lastExitTier) + "-F4E"
    strategy.close_all(comment=exitComment)
else if trendFilterFail
    lastExitType := "F1E"
    lastExitTier := currentTierCount + 1
    exitComment = "T" + str.tostring(lastExitTier) + "-F1E"
    strategy.close_all(comment=exitComment)

// Reset tracking on position close
if strategy.position_size == 0
    currentTierCount := 0
    lastTierPrice := na
    if strategy.position_size[1] > 0
        lastEntryType := na
        lastEntryTier := na
        lastExitType := na
        lastExitTier := na// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                H I S T O R I C A L   Z O N E   M A N A G E M E N T                          |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// Zone colors with user-configurable transparency
PROFIT_ZONE_COLOR = color.new(color.green, zoneTransparency)
RISK_ZONE_COLOR = color.new(color.red, zoneTransparency)
DARK_RED_LINE = color.new(color.red, 0)

// Historical zone constants
MAX_ZONES = maxHistoricalZones

// Zone array memory management (moved to main scope per Pine Script v6 requirements)
if array.size(historicalProfitZones) > MAX_ZONES
    oldBox = array.shift(historicalProfitZones)
    if not na(oldBox)
        box.delete(oldBox)

if array.size(historicalRiskZones) > MAX_ZONES
    oldBox = array.shift(historicalRiskZones)
    if not na(oldBox)
        box.delete(oldBox)

if array.size(historicalStopLossLines) > MAX_ZONES
    oldLine = array.shift(historicalStopLossLines)
    if not na(oldLine)
        line.delete(oldLine)// Zone management for ACTIVE trades (per UI specifications)
if strategy.position_size > 0 and not na(currentStopPrice) and not na(tradeStartBar) and not na(tradeEntryPrice) and currentStopPrice > 0
    currentPrice = close
    upperBound = math.max(high * 1.05, currentPrice * 1.10)
    
    if showProfitZone and upperBound > tradeEntryPrice and tradeStartBar <= bar_index
        if na(currentProfitZone)
            currentProfitZone := box.new(left=tradeStartBar, top=upperBound, right=bar_index, bottom=tradeEntryPrice, bgcolor=PROFIT_ZONE_COLOR, border_color=color.new(color.green, 50), border_width=1, extend=extend.none)
        else
            box.set_right(currentProfitZone, bar_index)
            box.set_top(currentProfitZone, upperBound)
    
    if showRiskZone and tradeEntryPrice > currentStopPrice and currentStopPrice > 0 and tradeStartBar <= bar_index
        if na(currentRiskZone)
            currentRiskZone := box.new(left=tradeStartBar, top=tradeEntryPrice, right=bar_index, bottom=currentStopPrice, bgcolor=RISK_ZONE_COLOR, border_color=color.new(color.red, 50), border_width=1, extend=extend.none)
        else
            box.set_right(currentRiskZone, bar_index)
            box.set_bottom(currentRiskZone, currentStopPrice)
    
    if showStopLossLine and currentStopPrice > 0 and tradeStartBar <= bar_index
        if na(currentStopLossLine)
            currentStopLossLine := line.new(x1=tradeStartBar, y1=currentStopPrice, x2=bar_index, y2=currentStopPrice, color=DARK_RED_LINE, width=2, extend=extend.none, style=line.style_solid)
        else
            line.set_xy2(currentStopLossLine, bar_index, currentStopPrice)
            line.set_y1(currentStopLossLine, currentStopPrice)// Handle trade EXIT - finalize zones and preserve them historically
if strategy.position_size == 0 and strategy.position_size[1] > 0
    tradeExitPrice := baseTF_close
    
    if showHistoricalZones
        if not na(currentProfitZone) and showProfitZone
            box.set_right(currentProfitZone, bar_index)
            array.push(historicalProfitZones, currentProfitZone)
            currentProfitZone := na
        
        if not na(currentRiskZone) and showRiskZone
            box.set_right(currentRiskZone, bar_index)
            array.push(historicalRiskZones, currentRiskZone)
            currentRiskZone := na
        
        if not na(currentStopLossLine) and showStopLossLine
            line.set_x2(currentStopLossLine, bar_index)
            array.push(historicalStopLossLines, currentStopLossLine)
            currentStopLossLine := na
    
    if not showHistoricalZones
        if not na(currentProfitZone)
            box.delete(currentProfitZone)
            currentProfitZone := na
        if not na(currentRiskZone)
            box.delete(currentRiskZone)
            currentRiskZone := na
        if not na(currentStopLossLine)
            line.delete(currentStopLossLine)
            currentStopLossLine := na
    
    tradeStartBar := na
    tradeEntryPrice := na

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// |                                V I S U A L   I N T E R F A C E                             |
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

// UI Colors
BRIGHT_BLUE = color.new(#0080FF, 0)
BRIGHT_ORANGE = color.new(#FF8000, 0)
PROFESSIONAL_BLUE = color.new(color.blue, 20)
SUBTLE_GREEN = color.new(color.green, 97)// Essential plots
plot(showTrendSma ? trendSma : na, "200 SMA", color=PROFESSIONAL_BLUE, linewidth=1)

// Entry/Exit detection patterns
entryDetected = strategy.position_size > 0 and strategy.position_size[1] == 0
exitDetected = strategy.position_size == 0 and strategy.position_size[1] > 0

// Entry/Exit arrows
plotshape(showEntryArrows and entryDetected, "Entry Arrow", shape.arrowup, location.belowbar, BRIGHT_BLUE, size=size.small)
plotshape(showExitArrows and exitDetected, "Exit Arrow", shape.arrowdown, location.abovebar, BRIGHT_ORANGE, size=size.small)

// Background colors for trade zones
positionZone = strategy.position_size > 0
bgcolor(showStopLevels and positionZone ? SUBTLE_GREEN : na, title="Position Status")

// Debug information table with Universal HTF details and robustness indicators
if showDebugInfo
    // HTF Guardrails and Validation
    htfHistorySufficient = bar_index >= 300  // Minimum bars for reliable age validation
    breakoutHTFValid = timeframe.in_seconds(breakoutHTF) >= timeframe.in_seconds(baseTF)
    dipHTFValid = timeframe.in_seconds(dipBuyHTF) >= timeframe.in_seconds(baseTF)
    htfWarning = not htfHistorySufficient or not breakoutHTFValid or not dipHTFValid
    
    debugTable = table.new(position.top_right, 2, 20, bgcolor=color.new(color.white, 80), border_width=1)
    table.cell(debugTable, 0, 0, "ğŸ›¡ï¸ UNIVERSAL MTP v4", bgcolor=htfWarning ? color.new(color.red, 70) : color.new(color.blue, 70), text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 0, "Values", bgcolor=htfWarning ? color.new(color.red, 70) : color.new(color.blue, 70), text_color=color.white, text_size=size.small)
    table.cell(debugTable, 0, 1, "âš¡ Base TF", text_size=size.small)
    table.cell(debugTable, 1, 1, baseTF, text_size=size.small)
    table.cell(debugTable, 0, 2, "âš¡ Breakout HTF", text_size=size.small)
    table.cell(debugTable, 1, 2, breakoutHTF + (breakoutHTFValid ? " âœ…" : " âš ï¸"), text_size=size.small)
    table.cell(debugTable, 0, 3, "âš¡ Dip HTF", text_size=size.small)
    table.cell(debugTable, 1, 3, dipBuyHTF + (dipHTFValid ? " âœ…" : " âš ï¸"), text_size=size.small)
    table.cell(debugTable, 0, 4, "âš¡ History", text_size=size.small)
    table.cell(debugTable, 1, 4, str.tostring(bar_index) + " bars " + (htfHistorySufficient ? "âœ…" : "âš ï¸<300"), text_size=size.small)
    table.cell(debugTable, 0, 5, "âš¡ Futures Mode", text_size=size.small)
    table.cell(debugTable, 1, 5, enableFuturesMode ? "ON" : "OFF", text_size=size.small)
    table.cell(debugTable, 0, 6, "âš¡ Contract Valid", text_size=size.small)
    table.cell(debugTable, 1, 6, contractDataValid ? "âœ…" : "âŒ", text_size=size.small)
    table.cell(debugTable, 0, 7, "âš¡ Point Value", text_size=size.small)
    table.cell(debugTable, 1, 7, str.tostring(contractPointValue, "##.##"), text_size=size.small)
    table.cell(debugTable, 0, 8, "Position Size", text_size=size.small)
    table.cell(debugTable, 1, 8, str.tostring(strategy.position_size, "##.##"), text_size=size.small)
    table.cell(debugTable, 0, 9, "Entry Price", text_size=size.small)
    table.cell(debugTable, 1, 9, not na(tradeEntryPrice) ? str.tostring(tradeEntryPrice, "##.##") : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 10, "Current Stop", text_size=size.small)
    table.cell(debugTable, 1, 10, not na(currentStopPrice) ? str.tostring(currentStopPrice, "##.##") : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 11, "ğŸ” ATR (100-period)", text_size=size.small)
    table.cell(debugTable, 1, 11, not na(atr) and atr != 0 ? str.tostring(atr, "##.####") : (na(atr) ? "NA" : "ZERO"), text_size=size.small)
    table.cell(debugTable, 0, 12, "ğŸ” HTF High", text_size=size.small)
    table.cell(debugTable, 1, 12, not na(htfHigh) ? str.tostring(htfHigh, "##.##") : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 13, "ğŸ” HTF Low", text_size=size.small)
    table.cell(debugTable, 1, 13, not na(htfLow) ? str.tostring(htfLow, "##.##") : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 14, "ğŸ” High Age", text_size=size.small)
    table.cell(debugTable, 1, 14, not na(htfHighAge) ? str.tostring(htfHighAge) + " bars" : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 15, "ğŸ” Low Age", text_size=size.small)
    table.cell(debugTable, 1, 15, not na(htfLowAge) ? str.tostring(htfLowAge) + " bars" : "N/A", text_size=size.small)
    table.cell(debugTable, 0, 16, "ğŸ” Reference Asset", text_size=size.small)
    table.cell(debugTable, 1, 16, useReferenceAsset and not na(referenceClose) ? str.tostring(referenceClose, "##.##") : "Disabled", text_size=size.small)
    table.cell(debugTable, 0, 17, "ğŸ” Trail Distance", text_size=size.small)
    table.cell(debugTable, 1, 17, str.tostring(adjustedAtrTrailMultiplier, "#.#") + " ATR", text_size=size.small)
    table.cell(debugTable, 0, 18, "Trail Activated", text_size=size.small)
    table.cell(debugTable, 1, 18, trailStartActivated ? "YES" : "NO", text_size=size.small)
    table.cell(debugTable, 0, 19, "Data Valid", text_size=size.small)
    table.cell(debugTable, 1, 19, isDataValid ? "YES" : "NO", text_size=size.small)